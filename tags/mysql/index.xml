<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Mysql on Tachikoma blog </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://ikarishinjieva.github.io/tachikoma-blog/tags/mysql/index.xml/</link>
    <language>zh-cn</language>
    
    
    <updated>Thu, 13 Nov 2014 19:44:00 UTC</updated>
    
    <item>
      <title>Mysql 出现ER_GTID_NEXT_TYPE_UNDEFINED_GROUP的第三种可能</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-11-13-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP-3</link>
      <pubDate>Thu, 13 Nov 2014 19:44:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-11-13-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP-3</guid>
      <description>

&lt;p&gt;之前讨论过两种出现ER_GTID_NEXT_TYPE_UNDEFINED_GROUP的可能(&lt;a href=&#34;http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-05-mysql-er_gtid_next_type_undefined_group/&#34;&gt;可能1&lt;/a&gt;和&lt;a href=&#34;http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-17-mysql-er_gtid_next_type_undefined_group-2/&#34;&gt;可能2&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;但都不是之前在线上环境见到的状况, 前几天QA重现了线上的情况, 经过几天的折腾, 终于找到了原因.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;结论&lt;/h3&gt;

&lt;p&gt;先说结论, Mysql 5.6.21以下的Mysql版本会出现这个错误, 导致复制不正常, 发生&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;错误, 而如果强行&lt;code&gt;start slave&lt;/code&gt;, 会永久丢失一个事务, 导致主从数据不一致.&lt;/p&gt;

&lt;p&gt;这个错误的发生概率还是较大的, 如果使用了GTID, 并且使用了&lt;code&gt;master_auto_position&lt;/code&gt;来建立复制, 那建议升级到Mysql 5.6.21.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;如何重现&lt;/h3&gt;

&lt;p&gt;先用下面的patch修改Mysql源码, 这段patch用于增加debug点 (如果不想修改源码, 也可用gdb手工模仿):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- rpl_slave.cc.orig     2014-11-12 16:03:36.000000000 +0800
+++ rpl_slave.cc     2014-11-12 16:05:18.000000000 +0800
@@ -4378,6 +4378,14 @@
       THD_STAGE_INFO(thd, stage_queueing_master_event_to_the_relay_log);
       event_buf= (const char*)mysql-&amp;gt;net.read_pos + 1;
       DBUG_PRINT(&amp;quot;info&amp;quot;, (&amp;quot;IO thread received event of type %s&amp;quot;, Log_event::get_type_str((Log_event_type)event_buf[EVENT_TYPE_OFFSET])));
+
+      DBUG_EXECUTE_IF(&amp;quot;stop_io_before_reading_xid_log_event&amp;quot;,
+        if (event_buf[EVENT_TYPE_OFFSET] == XID_EVENT) {
+           thd-&amp;gt;killed= THD::KILLED_NO_VALUE;
+           goto err;
+        }
+      );
+
       if (RUN_HOOK(binlog_relay_io, after_read_event,
                    (thd, mi,(const char*)mysql-&amp;gt;net.read_pos + 1,
                     event_len, &amp;amp;event_buf, &amp;amp;event_len)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行下面的mysql-test脚本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--source include/have_debug.inc
--source include/have_gtid.inc

--disable_warnings
--source include/master-slave.inc
--enable_warnings

--connection master
create table test.a(a int) engine=innodb;
flush logs;
--source include/sync_slave_sql_with_master.inc

--connection slave
stop slave;
set global debug=&amp;quot;d,stop_io_before_reading_xid_log_event&amp;quot;;

--connection master
begin;
insert into test.a values(1);
insert into test.a values(2);
commit;

--connection slave
start slave io_thread;
--let $slave_param= Slave_IO_Running
--let $slave_param_value= No
--source include/wait_for_slave_param.inc

--connection slave
set global debug=&amp;quot;&amp;quot;;

start slave;
--let $slave_param= Slave_SQL_Running
--let $slave_param_value= No
--source include/wait_for_slave_param.inc

--let $errno= query_get_value(&amp;quot;SHOW SLAVE STATUS&amp;quot;, &amp;quot;Last_Errno&amp;quot;, 1)
--if ($errno != &amp;quot;1837&amp;quot;) {
    --echo Got unexpect errno=$errno
    --die
}
--echo Got Slave SQL error 1837

# Cleanup
--connection master
drop table test.a;

--connection slave
set global debug=&amp;quot;&amp;quot;;
start slave;
--source include/sync_slave_sql_with_master.inc
--source include/rpl_end.inc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Mysql 5.6.&lt;sup&gt;19&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;.6.20上都能成功重现.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Bug分析&lt;/h3&gt;

&lt;p&gt;重现这个bug需要具备以下前提条件:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mysql使用GTID&lt;/li&gt;
&lt;li&gt;Mysql复制使用了&lt;code&gt;master_auto_position&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对重现的每个步骤进行说明:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先需要在Master上进行&lt;code&gt;flush logs&lt;/code&gt;, 这样生成的binlog和一般binlog的区别是&lt;code&gt;created&lt;/code&gt;段值为0 (&lt;strong&gt;正常的binlog rotate也会产生这个效果&lt;/strong&gt;). 关于&lt;code&gt;created&lt;/code&gt;在Mysql源码中是如下说明的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
If this event is at the start of the first binary log since server
startup &#39;created&#39; should be the timestamp when the event (and the
binary log) was created.  In the other case (i.e. this event is at
the start of a binary log created by FLUSH LOGS or automatic
rotation), &#39;created&#39; should be 0.  This &amp;quot;trick&amp;quot; is used by MySQL
&amp;gt;=4.0.14 slaves to know whether they must drop stale temporary
tables and whether they should abort unfinished transaction.
...
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额外一提, &lt;code&gt;mysqlbinlog&lt;/code&gt;在解析binlog时对&lt;code&gt;created&lt;/code&gt;段解析是有问题的, 建议直接使用&lt;code&gt;mysqlbinlog --hexdump&lt;/code&gt;来看&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;然后在Slave上设置新加的debug点&lt;code&gt;stop_io_before_reading_xid_log_event&lt;/code&gt;, 并开启IO复制线程.&lt;/p&gt;

&lt;p&gt;在Master上插入以下事务:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin;
insert into test.a values(1);
insert into test.a values(2);
commit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样IO复制线程会在commit之前停下来, 假设正在使用relay-log.000001, 那这个relay log中就只含有begin和两个insert&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下来去掉debug点,再次开启IO复制线程.&lt;/p&gt;

&lt;p&gt;由于Mysql复制使用了&lt;code&gt;master_auto_position&lt;/code&gt;(前提条件2), 就会重传整个事务, 得到以下的relay log:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---relay-log.000001
...
GTID
begin;
insert into test.a values(1);
insert into test.a values(2);
ROTATE

--relay-log.000002
slave FDE (Format_description_event)
Previous-gtid
Rotate
master FDE (created=0)
Rotate&#39;
Rotate&#39;&#39;
GTID
begin;
insert into test.a values(1);
insert into test.a values(2);
commit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两点说明:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果不使用&lt;code&gt;master_auto_position&lt;/code&gt;, 就不会重传整个事务, 而是断点续传&lt;/li&gt;
&lt;li&gt;relay-log.000002开头好几个rotate看起来比较复杂, 可以先忽略这个细节, 对整个bug没有影响
得到上面的relay-log后, 如果开启sql线程会发生什么呢?&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;如果之前没有将&lt;code&gt;created&lt;/code&gt;段置为0的那一步, 一切运行都会是正常的, 原因是在master FDE的处理中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Format_description_log_event::do_apply_event
  /*
    As a transaction NEVER spans on 2 or more binlogs:
    if we have an active transaction at this point, the master died
    while writing the transaction to the binary log, i.e. while
    flushing the binlog cache to the binlog. XA guarantees that master has
    rolled back. So we roll back.
    Note: this event could be sent by the master to inform us of the
    format of its binlog; in other words maybe it is not at its
    original place when it comes to us; we&#39;ll know this by checking
    log_pos (&amp;quot;artificial&amp;quot; events have log_pos == 0).
  */
  if (!is_artificial_event() &amp;amp;&amp;amp; created &amp;amp;&amp;amp; thd-&amp;gt;transaction.all.ha_list)
  {
    /* This is not an error (XA is safe), just an information */
    rli-&amp;gt;report(INFORMATION_LEVEL, 0,
                &amp;quot;Rolling back unfinished transaction (no COMMIT &amp;quot;
                &amp;quot;or ROLLBACK in relay log). A probable cause is that &amp;quot;
                &amp;quot;the master died while writing the transaction to &amp;quot;
                &amp;quot;its binary log, thus rolled back too.&amp;quot;); 
    const_cast&amp;lt;Relay_log_info*&amp;gt;(rli)-&amp;gt;cleanup_context(thd, 1);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前存在事务(&lt;code&gt;thd-&amp;gt;transaction.all.ha_list&lt;/code&gt;), 且master FDE标明它是master启动时产生的binlog, 那slave会将当前事务回滚掉(&lt;code&gt;cleanup_context&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;如果master在写入binlog时崩溃, master重启后会回滚binlog,那slave也会相应产生回滚.&lt;/p&gt;

&lt;p&gt;由于我们之前设置了&lt;code&gt;created&lt;/code&gt;为0, 这个机制就不起作用. 之后会发生什么呢?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;sql线程是这样执行的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从relay-log.000001往下执行, 进入事务&lt;/li&gt;
&lt;li&gt;发现Rotate, 轮换到relay-log.000002, 但事务并没有结束, 就仿佛一个事务跨了两个relay log(一个事务是可以跨多个relay log)&lt;/li&gt;
&lt;li&gt;master FDE的保护机制由于FDE的&lt;code&gt;created&lt;/code&gt;为0而失效, 可以继续执行, 且仍在事务中&lt;/li&gt;
&lt;li&gt;GTID event将当前线程的&lt;code&gt;GTID_NEXT&lt;/code&gt;值重置, 但&lt;strong&gt;并不会回滚事务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BEGIN event会将当前事务提交, 清掉&lt;code&gt;GTID_NEXT&lt;/code&gt;, 并开始新的事务&lt;/li&gt;
&lt;li&gt;之后的insert发现&lt;code&gt;GTID_NEXT&lt;/code&gt;已经为空, 故报了&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;的错误&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;需要说明一下BEGIN event为什么会提交事务. 这也很好理解, 如果执行下面的语句:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN;
insert into test.a values(444);
BEGIN;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Mysql中正常的流程是insert会被隐式提交. 但在执行relay log时, 这样的处理就会导致新的事务丢失了GTID事件.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Mysql 5.6.21的修复&lt;/h3&gt;

&lt;p&gt;之前我们提到了: GTID event将当前线程的&lt;code&gt;GTID_NEXT&lt;/code&gt;值重置, 但&lt;strong&gt;并不会回滚事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而Mysql 5.6.21进行的修复就是让GTID event进行事务回滚, 代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Gtid_log_event::do_apply_event
if (thd-&amp;gt;owned_gtid.sidno)
{
    /*
      Slave will execute this code if a previous Gtid_log_event was applied
      but the GTID wasn&#39;t consumed yet (the transaction was not committed
      nor rolled back).
      On a client session we cannot do consecutive SET GTID_NEXT without
      a COMMIT or a ROLLBACK in the middle.
      Applying this event without rolling back the current transaction may
      lead to problems, as a &amp;quot;BEGIN&amp;quot; event following this GTID will
      implicitly commit the &amp;quot;partial transaction&amp;quot; and will consume the
      GTID. If this &amp;quot;partial transaction&amp;quot; was left in the relay log by the
      IO thread restarting in the middle of a transaction, you could have
      the partial transaction being logged with the GTID on the slave,
      causing data corruption on replication.
    */
    if (thd-&amp;gt;transaction.all.ha_list)
    {
      /* This is not an error (XA is safe), just an information */
      rli-&amp;gt;report(INFORMATION_LEVEL, 0,
                  &amp;quot;Rolling back unfinished transaction (no COMMIT &amp;quot;
                  &amp;quot;or ROLLBACK in relay log). A probable cause is partial &amp;quot;
                  &amp;quot;transaction left on relay log because of restarting IO &amp;quot;
                  &amp;quot;thread with auto-positioning protocol.&amp;quot;);
      const_cast&amp;lt;Relay_log_info*&amp;gt;(rli)-&amp;gt;cleanup_context(thd, 1);
    }
    gtid_rollback(thd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;gtid_rollback&lt;/code&gt;是在之前版本中就有, 是用来回滚GTID信息的. 而&lt;code&gt;if (thd-&amp;gt;transaction.all.ha_list)&lt;/code&gt;中的是Mysql 5.6.21的修复部分.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql 出现ER_GTID_NEXT_TYPE_UNDEFINED_GROUP的第二种可能</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-17-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP-2</link>
      <pubDate>Wed, 17 Sep 2014 09:33:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-17-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP-2</guid>
      <description>

&lt;p&gt;之前&lt;a href=&#34;http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-05-mysql-er_gtid_next_type_undefined_group/&#34;&gt;讨论&lt;/a&gt;过Mysql出现以下错误的一种可能:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When @@SESSION.GTID_NEXT is set to a GTID, you must explicitly set it to a different value after a COMMIT or ROLLBACK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面描述的另一种可能来自于taobao的&lt;a href=&#34;http://mysql.taobao.org/index.php/MySQL内核月报_2014.09&#34;&gt;Mysql内核月报&lt;/a&gt;. 主要涉及到&lt;code&gt;insert delayed&lt;/code&gt;语句.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;关于&lt;code&gt;insert delayed&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是关于&lt;code&gt;insert delayed&lt;/code&gt;的几个描述:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert delayed&lt;/code&gt;对客户端立刻返回, 而将实际数据任务排队到合适的时候才进行.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert delayed&lt;/code&gt;仅支持MyISAM表, 且在Mysql 5.6.6及以后deprecate, 但在目前Mysql 5.6.20中仍可使用.&lt;/li&gt;
&lt;li&gt;对于Mixed和Row格式的binlog, &lt;code&gt;insert delayed&lt;/code&gt;将使用Row格式. 而对于Statement格式, &lt;code&gt;insert delayed&lt;/code&gt;将退化成普通的&lt;code&gt;insert&lt;/code&gt;语句. (&lt;code&gt;sql_insert.cc:upgrade_lock_type&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;bug描述&lt;/h3&gt;

&lt;p&gt;在master上执行以下脚本, 可以在slave上看到复制的error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/opt/mysql/bin/mysql -uroot -h127.0.0.1 -e &amp;quot;CREATE TABLE a (a int) ENGINE=MyISAM&amp;quot;

for i in {1..2}
do
/opt/mysql/bin/mysql -uroot -h127.0.0.1 -e &amp;quot;insert delayed into test.a values(1)&amp;quot; &amp;amp;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;分析&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;insert delayed&lt;/code&gt;的执行可以看做分为两个部分: 生产者和消费者.&lt;/p&gt;

&lt;p&gt;同时执行的两个&lt;code&gt;insert delayed&lt;/code&gt;, 会触发两个生产者线程将两次执行排队到队列中, 等待消费者进行消费&lt;/p&gt;

&lt;p&gt;消费者线程的大概流程是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle_delayed_insert
     Delayed_insert::handle_inserts
          while(row = rows.get()) {
               write binlog
               write table
          }
     trans_commit_stmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其形成的binlog形式是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GTID_DESC
BEGIN
row_event 1
row_event 2
COMMIT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段binlog在slave上重放时, row_event 1结束后会进行commit, 对GTID执行&lt;code&gt;set_undefined&lt;/code&gt; (如果不理解这一段, 请参看&lt;a href=&#34;http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-05-mysql-er_gtid_next_type_undefined_group/&#34;&gt;之前的讨论&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;执行row_event 2时就找不到GTID的描述, 故error&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;何时commit&lt;/h3&gt;

&lt;p&gt;上面的分析有一部分是有点奇怪的, 就是``row_event 1结束后会进行commit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;对比另外一个场景, 如果进行一个大的insert, 比如&lt;code&gt;insert into a values(1),(2),(3),...,(100000)&lt;/code&gt;, 形成的binlog形式与上面一模一样, 但仅在最后一个row_event时进行commit&lt;/p&gt;

&lt;p&gt;造成这种差异的原因在于标识&lt;code&gt;STMT_END_F&lt;/code&gt;,  在bug的场景中,  两个row_event都带有标识&lt;code&gt;STMT_END_F&lt;/code&gt;, 故会在每个row_event执行后进行commit&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;复盘&lt;/h3&gt;

&lt;p&gt;这个bug主要的成因是两个并行&lt;code&gt;insert delayed&lt;/code&gt;会组合在一起向master提交, 且提交成功. 而根据binlog, slave执行时会进行两次commit, 但共用了同一个GTID_DESC, 所以会发生错误.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql 出现ER_GTID_NEXT_TYPE_UNDEFINED_GROUP的一种可能</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-05-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP</link>
      <pubDate>Fri, 05 Sep 2014 22:00:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-05-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP</guid>
      <description>

&lt;p&gt;最近Mysql slave发生了一次下面的错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When @@SESSION.GTID_NEXT is set to a GTID, you must explicitly set it to a different value after a COMMIT or ROLLBACK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为没留下现场, 分析起来很困难. 从mysql bug库中刨出了一个类似的&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=68525&#34;&gt;bug 68525&lt;/a&gt;, 分析了这个bug的成因.&lt;/p&gt;

&lt;p&gt;BTW, 不幸的是分析完后觉得与之前碰到场景不一致.&lt;/p&gt;

&lt;p&gt;下面将介绍这个bug的成因.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;bug描述&lt;/h3&gt;

&lt;p&gt;重现这个bug需满足下面的条件:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;relay-log-info-repository = TABLE&lt;/li&gt;
&lt;li&gt;gtid-mode = on&lt;/li&gt;
&lt;li&gt;binlog-format = ROW&lt;/li&gt;
&lt;li&gt;max_binlog_size 足够小, 我设置为 4096&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用下面的脚本在master上创建&lt;strong&gt;myisam&lt;/strong&gt;表并灌数据, slave上就会出现&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `item` (`id` int(11) NOT NULL AUTO_INCREMENT,`item` varchar(10), PRIMARY KEY (`id`)) ENGINE=myisam DEFAULT CHARSET=utf8 COLLATE=utf8_czech_ci;

insert into item(item) values (&#39;test1&#39;) ;

insert into item(item) values (&#39;test2&#39;) ;

insert into item(item) values (&#39;test3&#39;) ;

insert into item(item) values (&#39;test4&#39;) ;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

insert into item(item) select item from item;

#最后一组数据是1024行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普遍的解决方法是在slave上&lt;code&gt;stop slave; start slave&lt;/code&gt;就可以从这个错误中恢复, 但注意此时master和slave上数据是&lt;strong&gt;不一致&lt;/strong&gt;的&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;row event的拆分&lt;/h3&gt;

&lt;p&gt;进行更进一步的描述前, 先需要理解row event的拆分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在master端, 当row event的大小超过&lt;code&gt;binlog-row-event-max-size&lt;/code&gt;时, 会使用一个新的row event.  &lt;code&gt;binlog-row-event-max-size&lt;/code&gt;默认大小为8k, 即如果更新1000行, 会被拆成若干个8k的row event&lt;/li&gt;
&lt;li&gt;在master端, 无论&lt;code&gt;max_binlog_size&lt;/code&gt;多小, 一次提交的row event都会存放在同一个binlog中, 即如果更新1000行, 所有的row event都会放在同一个binlog中 (即使更新的是myisam表)&lt;/li&gt;
&lt;li&gt;在slave端, relay log以event为单位接受master发送的binlog, 如果当前relay log大小超过&lt;code&gt;max_relay_log_size&lt;/code&gt;, relay log进行轮换. 即之前的1000行更新在slave端会被&lt;strong&gt;拆分&lt;/strong&gt;到若干个relay log中. 本例中&lt;code&gt;max_relay_log_size = 0&lt;/code&gt;, relay log的大小限制同&lt;code&gt;max_binlog_size&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;错误发生在何处&lt;/h3&gt;

&lt;p&gt;理解了row event会被拆分到多个relay log中, 那从relay log的角度:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;===
# relay-log.000001
GTID_desc event
BEGIN event
row_event 0
row_event 1
...
row_event x
ROTATE event
===
# relay-log.000002
Format_description_event
Previous-GTIDs
...
# &amp;lt;-- 错误发生在此处!
row_event x+1
...
COMMIT event
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误发生在新的relay-log执行第x+1个row_event之前, 发生错误时可以看到slave的&lt;code&gt;executed_gtid&lt;/code&gt;已经按照GTID_desc event的描述更新了, 这意味着两件事情:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可能在relay-log轮换时发生了commit, 导致还未执行完的更新(只执行到了row_event x)将其gtid刷到了&lt;code&gt;executed_gtid&lt;/code&gt;中,  这可能是bug发生的原因.&lt;/li&gt;
&lt;li&gt;如果此时执行&lt;code&gt;stop slave; start slave&lt;/code&gt;, 那么整个更新将被跳过, &lt;strong&gt;这就是为什么可以从错误中恢复&lt;/strong&gt;. 但&lt;code&gt;row_event x&lt;/code&gt;以后的更新将丢失, &lt;strong&gt;造成数据不一致&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;为什么会抛出错误&lt;/h3&gt;

&lt;p&gt;检查一下&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;的抛出处&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gtid_pre_statement_checks {
     …
     if (UNDEFINED_GROUP == gtid_next-&amp;gt;type) {
          my_error(ER_GTID_NEXT_TYPE_UNDEFINED_GROUP, MYF(0), buf);
     }
     …
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那设置&lt;code&gt;gtid_next-&amp;gt;type = UNDEFINED_GROUP&lt;/code&gt;的地方在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set_undefined() {
     if (type == GTID_GROUP)
          type= UNDEFINED_GROUP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;set_undefined&lt;/code&gt;被很多逻辑分支调用, 都是Mysql确定当前Gtid被使用完毕或者需要抛弃时被调用, 比如commit和rollback时.&lt;/p&gt;

&lt;p&gt;那如之前的猜想, 在relay log 轮换时发生了commit, 就会&lt;code&gt;set_undefined&lt;/code&gt;, &lt;code&gt;row_event x+1&lt;/code&gt;执行前的检查就会抛出&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;用断点追踪一下也应正了这个猜想:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#0  Gtid_specification::set_undefined (this=0x7f8e940011b8) at /opt/mysql-src-5.6.19/sql/rpl_gtid.h:2413
#1  0x0000000000a0a9ed in Gtid_state::update_on_flush (this=0x2c14310, thd=0x7f8e940008c0)
    at /opt/mysql-src-5.6.19/sql/rpl_gtid_state.cc:170
#2  0x0000000000a4788d in MYSQL_BIN_LOG::write_cache (this=0x1826c00, thd=0x7f8e940008c0,
    cache_data=0x7f8e94035b40) at /opt/mysql-src-5.6.19/sql/binlog.cc:5799
#3  0x0000000000a3b803 in binlog_cache_data::flush (this=0x7f8e94035b40, thd=0x7f8e940008c0,
    bytes_written=0x7f8ed5d9f0b0, wrote_xid=0x7f8ed5d9f107) at /opt/mysql-src-5.6.19/sql/binlog.cc:1227
#4  0x0000000000a5088d in binlog_cache_mngr::flush (this=0x7f8e94035b40, thd=0x7f8e940008c0,
    bytes_written=0x7f8ed5d9f108, wrote_xid=0x7f8ed5d9f107) at /opt/mysql-src-5.6.19/sql/binlog.cc:774
#5  0x0000000000a48f46 in MYSQL_BIN_LOG::flush_thread_caches (this=0x1826c00, thd=0x7f8e940008c0)
    at /opt/mysql-src-5.6.19/sql/binlog.cc:6368
#6  0x0000000000a49195 in MYSQL_BIN_LOG::process_flush_stage_queue (this=0x1826c00,
    total_bytes_var=0x7f8ed5d9f280, rotate_var=0x7f8ed5d9f27f, out_queue_var=0x7f8ed5d9f270)
    at /opt/mysql-src-5.6.19/sql/binlog.cc:6424
#7  0x0000000000a49eb7 in MYSQL_BIN_LOG::ordered_commit (this=0x1826c00, thd=0x7f8e940008c0, all=false,
    skip_commit=false) at /opt/mysql-src-5.6.19/sql/binlog.cc:6841
#8  0x0000000000a48e6a in MYSQL_BIN_LOG::commit (this=0x1826c00, thd=0x7f8e940008c0, all=false)
    at /opt/mysql-src-5.6.19/sql/binlog.cc:6335
#9  0x0000000000644bdb in ha_commit_trans (thd=0x7f8e940008c0, all=false, ignore_global_read_lock=true)
    at /opt/mysql-src-5.6.19/sql/handler.cc:1436
#10 0x0000000000a9214d in Rpl_info_table_access::close_table (this=0x32c1b20, thd=0x7f8e940008c0,
    table=0x3371800, backup=0x7f8ed5da0520, error=false) at /opt/mysql-src-5.6.19/sql/rpl_info_table_access.cc:163
#11 0x0000000000a9075f in Rpl_info_table::do_flush_info (this=0x32c1ba0, force=true)
    at /opt/mysql-src-5.6.19/sql/rpl_info_table.cc:238
#12 0x0000000000a7def4 in Rpl_info_handler::flush_info (this=0x32c1ba0, force=true)
    at /opt/mysql-src-5.6.19/sql/rpl_info_handler.h:92
#13 0x0000000000a842c9 in Relay_log_info::flush_info (this=0x3355240, force=true)
    at /opt/mysql-src-5.6.19/sql/rpl_rli.cc:2028
#14 0x0000000000a42871 in MYSQL_BIN_LOG::purge_first_log (this=0x3355980, rli=0x3355240, included=false)
    at /opt/mysql-src-5.6.19/sql/binlog.cc:3966
#15 0x0000000000a7805d in next_event (rli=0x3355240) at /opt/mysql-src-5.6.19/sql/rpl_slave.cc:7362
#16 0x0000000000a6dd60 in exec_relay_log_event (thd=0x7f8e940008c0, rli=0x3355240)
    at /opt/mysql-src-5.6.19/sql/rpl_slave.cc:3814
#17 0x0000000000a73646 in handle_slave_sql (arg=0x2c197b0) at /opt/mysql-src-5.6.19/sql/rpl_slave.cc:5708
#18 0x0000000000e1e0b1 in pfs_spawn_thread (arg=0x7f8eb0050080)
    at /opt/mysql-src-5.6.19/storage/perfschema/pfs.cc:1860
#19 0x00007f8f03ef89d1 in start_thread () from /lib64/libpthread.so.0
#20 0x00007f8f02e62b5d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;relay log进行轮换时&lt;code&gt;purge_first_log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rpl_info_table需要进行&lt;code&gt;flush_info&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导致了进行完整提交(&lt;code&gt;ordered_commit&lt;/code&gt;), 此时会&lt;code&gt;set_undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;为什么relay log轮换会触发完整提交&lt;/h3&gt;

&lt;p&gt;下面代码来自&lt;code&gt;MYSQL_BIN_LOG::commit&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (stuff_logged)
  {
    if (ordered_commit(thd, all))
      DBUG_RETURN(RESULT_INCONSISTENT);
  }
  else
  {
    if (ha_commit_low(thd, all))
      DBUG_RETURN(RESULT_INCONSISTENT);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交&lt;code&gt;Rpl_info_table&lt;/code&gt;时, 如果真的有&amp;rdquo;货&amp;rdquo;要提交(&lt;code&gt;stuff_logged&lt;/code&gt;), 就会用&lt;code&gt;ordered_commit&lt;/code&gt;做完整提交(包括&lt;code&gt;set_undefined&lt;/code&gt;); 否则, 用&lt;code&gt;ha_commit_low&lt;/code&gt;仅做innodb层的提交.&lt;/p&gt;

&lt;p&gt;所谓有&amp;rdquo;货&amp;rdquo;要提交, mysql源码的注释为:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We commit the transaction if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We are not in a transaction and committing a statement, or&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We are in a transaction and a full transaction is committed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Otherwise, we accumulate the changes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前这个bug满足第一种情况&lt;/li&gt;
&lt;li&gt;第二种情况解释了为什么使用innodb表时不会出现这个bug.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;最后验证一下&lt;code&gt;relay-log-info-repository=FILE&lt;/code&gt;时不会触发这个bug的.&lt;/p&gt;

&lt;p&gt;复盘一下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同一个commit的多个row event会被拆分到不同的relay log中.&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;relay-log-info-repository=TABLE&lt;/code&gt;时, 轮换relay log会触发commit.&lt;/li&gt;
&lt;li&gt;由于是myisam表, 则触发了一个完整commit (&lt;code&gt;ordered_commit&lt;/code&gt;). 会重置gtid状态为undefined.&lt;/li&gt;
&lt;li&gt;下一个relay log执行时, 发现gtid状态异常报错.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stop slave; start slave&lt;/code&gt;后, 由于gtid已经更新, 整个commit会被跳过, 造成数据丢失.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单地说就是&lt;code&gt;relay-log-info-repository=TABLE&lt;/code&gt;的交易性和myisam的非交易性在轮换relay log时的冲突.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql 5.6的crash-safe replication中与relay-log.info相关的部分</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-08-28-mysql-56-crash-safe</link>
      <pubDate>Thu, 28 Aug 2014 20:18:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-08-28-mysql-56-crash-safe</guid>
      <description>

&lt;p&gt;这篇blog目的是记录一下对Mysql 5.6 crash-safe replication的学习, 以及报给mysql的一个相关&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=73720&#34;&gt;bug&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先推荐Mats Kindahl写的关于crash safe的&lt;a href=&#34;http://mysqlmusings.blogspot.com/2011/04/crash-safe-replication.html&#34;&gt;科普&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;crash-safe&lt;/h3&gt;

&lt;p&gt;按照Mats Kindahl的分类, 在此仅涉及&amp;rdquo;crash-safe slaves&amp;rdquo;中与relay-log.info相关的部分&lt;/p&gt;

&lt;p&gt;Mysql crash-safe的名字起得并不好, 正确的名字应该是&lt;code&gt;crash-safe-only-for-DML-of-innodb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;涉及到DDL或非transactional型/非XA型的存储引擎时crash就不safe了, 比如这个&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=69444&#34;&gt;bug&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;bug&lt;/h3&gt;

&lt;p&gt;为了达成&lt;code&gt;crash-safe-only-for-DML-of-innodb&lt;/code&gt;,  需要开启&lt;code&gt;relay-log-info-repository = TABLE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;简单说明一下DDL/transactional DML/non-transactional DML的binlog event执行的区别:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DDL: &lt;code&gt;Query_event(DDL)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;transactional DML: &lt;code&gt;Query_event(Begin)&lt;/code&gt; -&amp;gt; &lt;code&gt;Query_event(DML)&lt;/code&gt; -&amp;gt; &lt;code&gt;Xid_event&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;non-transactional DML: &lt;code&gt;Query_event(Begin)&lt;/code&gt; -&amp;gt; &lt;code&gt;Query_event(DML)&lt;/code&gt; -&amp;gt; &lt;code&gt;Query_event(Commit)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中&lt;code&gt;Query_event&lt;/code&gt;中不会强制刷盘, 即&lt;code&gt;inc_group_relay_log_pos&lt;/code&gt;中调用的&lt;code&gt;flush_info(FALSE)&lt;/code&gt;; 而&lt;code&gt;Xid_event&lt;/code&gt;会强制刷盘.&lt;/p&gt;

&lt;p&gt;如果使用&lt;code&gt;relay-log-info-repository=FILE&lt;/code&gt;, 不强制刷盘时会进行&lt;code&gt;flush_io_cache&lt;/code&gt;, 强制刷盘时进行&lt;code&gt;my_sync&lt;/code&gt; (&lt;code&gt;Rpl_info_file::do_flush_info&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;如果使用&lt;code&gt;relay-log-info-repository=TABLE&lt;/code&gt;, 不强制刷盘时什么都不会做, 强制刷盘时才会更新表&lt;/p&gt;

&lt;p&gt;也就是说仅执行DDL/non-transactional DML时, &lt;code&gt;slave_relay_log_info&lt;/code&gt;的信息不会更新, 与&lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;中的信息不同&lt;/p&gt;

&lt;p&gt;报给了mysql一个&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=73720&#34;&gt;bug&lt;/a&gt;, 并被接受&lt;/p&gt;

&lt;p&gt;结论是谨慎使用&lt;code&gt;slave_relay_log_info&lt;/code&gt;中的值&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试Mysql 5.5的crash safe</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-08-17-mysql-55-crash-safe</link>
      <pubDate>Sun, 17 Aug 2014 19:13:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-08-17-mysql-55-crash-safe</guid>
      <description>&lt;p&gt;事情的起因有点意思, 前几天QA在参照&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=69444&#34;&gt;文档&lt;/a&gt;测试Mysql 5.6的crash safe特性. QA读到了源码里面的一段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if ((error= w-&amp;gt;commit_positions(this, ptr_group,
                                  w-&amp;gt;c_rli-&amp;gt;is_transactional())))
    goto err;

...

  DBUG_EXECUTE_IF(&amp;quot;crash_after_update_pos_before_apply&amp;quot;,
                  sql_print_information(&amp;quot;Crashing crash_after_update_pos_before_apply.&amp;quot;);
                  DBUG_SUICIDE(););

  error= do_commit(thd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并用&lt;code&gt;crash_after_update_pos_before_apply&lt;/code&gt;选项成功复现了bug.&lt;/p&gt;

&lt;p&gt;后来QA问我Mysql 5.5怎么测试crash safe, 因为她注意到Mysql 5.5的代码里并没有类似的测试插桩.&lt;/p&gt;

&lt;p&gt;读过Mysql 5.5的源码后, 找到了下面的位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int apply_event_and_update_pos(Log_event* ev, THD* thd, Relay_log_info* rli) {
    if (reason == Log_event::EVENT_SKIP_NOT)
    exec_res= ev-&amp;gt;apply_event(rli);
    ...
    //插入代码的位置
    if (exec_res == 0) {
        int error= ev-&amp;gt;update_pos(rli);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标记的位置插入代码&lt;code&gt;DBUG_EXECUTE_IF(&amp;quot;crash_after_apply_log_and_before_update_pos&amp;quot;, DBUG_SUICIDE(););&lt;/code&gt;, 重新编译Mysql就可以用&lt;code&gt;crash_after_apply_log_and_before_update_pos&lt;/code&gt;作为debug选项了.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] Fixing MySQL group commit</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-07-23-fix-mysql-group-commit</link>
      <pubDate>Wed, 23 Jul 2014 22:20:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-07-23-fix-mysql-group-commit</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;翻译之前&lt;/h1&gt;

&lt;p&gt;Kristian Nielsen写了Fixing MySQL group commit系列共四篇blog (&lt;a href=&#34;http://kristiannielsen.livejournal.com/12254.html&#34;&gt;第一篇&lt;/a&gt;, &lt;a href=&#34;http://kristiannielsen.livejournal.com/12408.html&#34;&gt;第二篇&lt;/a&gt;, &lt;a href=&#34;http://kristiannielsen.livejournal.com/12553.html&#34;&gt;第三篇&lt;/a&gt;, &lt;a href=&#34;http://kristiannielsen.livejournal.com/12810.html&#34;&gt;第四篇&lt;/a&gt;).
读完后对group commit的理解我觉得很有帮助, 因此想翻译前三篇, 借此再整理一下自己的思路; 第四篇偏重具体实现, 故不包括&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;第一篇&lt;/h1&gt;

&lt;p&gt;这个系列三篇文章描述了MySQL/MariaDB是如何支持group commit这个特性的. Group commit是对数据库性能一次重大的提升. 向持久存储里写数据的开销较大, group commit能减轻这种开销对数据库整体性能的影响.&lt;/p&gt;

&lt;p&gt;如下图所示, group commit对性能有很大提升:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://knielsen-hq.org/maria/fix-group-commit-1.png&#34; alt=&#34;引用原文图&#34; title=&#34;引用原文图&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;蓝色和黄色的上升线是group commit开启时的TPS, 其对性能改善的程度随着并发事务数的上升而提升&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;持久化和group commit&lt;/h2&gt;

&lt;p&gt;在一个传统事务系统中, 当事务提交成功时, 我们认为事务已经被_持久化(Durable)_了. Durable就是ACID中的D, 其含义是某事务提交成功后, 即使系统在其提交成功后任意时刻崩溃(比如电源故障, 内核崩盘, 服务器软件悲剧, 还有很多很多), 系统重启且从崩溃恢复后, 该事务的状态仍是提交成功的.&lt;/p&gt;

&lt;p&gt;确保持久化的通常手段是:提交时, 将足够的信息写入事务日志文件(transactional log file),然后用&lt;code&gt;fsync()&lt;/code&gt;将数据强制刷到磁盘上, 最后提交操作才成功返回.&lt;/p&gt;

&lt;p&gt;凭借这些信息数据库在崩溃重启后能进行完整恢复. 当然除了&lt;code&gt;fsync&lt;/code&gt;, 刷盘也可以通过&lt;code&gt;fdatasync()&lt;/code&gt;系统调用或者打开日志文件时用&lt;code&gt;O_DIRECT&lt;/code&gt;选项, 为了简便, 我们用&lt;code&gt;fsync()&lt;/code&gt;来代指刷盘操作.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fsync()&lt;/code&gt;是个昂贵的操作. 传统硬盘(HDD)每秒可以进行150次&lt;code&gt;fsync()&lt;/code&gt;, 而固态硬盘(比如Intel X25-M)每秒可进行1200次. 如果使用带电cache的RAID控制器, 可以减少&lt;code&gt;fsync()&lt;/code&gt;带来的性能影响, 但不能完全消除 ([译注]我也不太理解这句&amp;hellip;).&lt;/p&gt;

&lt;p&gt;(除了&lt;code&gt;fsync()&lt;/code&gt;, 也有其他的手段可以实现持久化. 比如在同步复制的集群(NDB,Galera)里, 假设全部节点不会同时故障, 那事务同步复制到多个节点, 就可以认为事务是持久化的. 不过不论用什么持久化方法, 较之只提交到本地内存, 持久化的代价要昂贵很多)&lt;/p&gt;

&lt;p&gt;如果每个提交都进行&lt;code&gt;fsync()&lt;/code&gt;, 受限于&lt;code&gt;fsync()&lt;/code&gt;的成本, 数据库TPS被限制在每秒150个事务(HDD).
Group commit能改善这个状况. 我们可以用一个&lt;code&gt;fsync()&lt;/code&gt;来合并多个事务同时发生的刷盘请求. 处理多个事务的刷盘请求, 较之处理一个事务, &lt;code&gt;fsync()&lt;/code&gt;的成本差别不大, 所以如性能图表所示, 合并刷盘请求能大幅提高性能.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Group commit in Mysql/MariaDB&lt;/h2&gt;

&lt;p&gt;Mysql在使用InnoDB存储引擎时可以提供完整的ACID. 对于InnoDB, 开启配置&lt;code&gt;innodb_flush_log_at_trx_commit=1&lt;/code&gt;时可保证持久性. MariaDB使用XtraDB的情况与之类似.&lt;/p&gt;

&lt;p&gt;使用持久化的原因, 一方面是已经提交的事务可以不受系统崩溃的影响, 另一方面, 是可以将数据库作为replication(数据复制)的master(复制源)&lt;/p&gt;

&lt;p&gt;数据复制使用binlog作为手段时, 保证binlog中的数据内容和存储引擎中的数据内容完全一致就很重要. 如果无法保证两者一致, slave(复制目标)将得到和master不一致的数据, 会产生无法估计的影响, 比如在master上进行的SQL无法在slave上成功执行.
如果不保证持久化, 在系统崩溃时很多数据将丢失, 如果存储引擎中丢失的数据和binlog中丢失的数据不一样多, 那最终两者数据将不一致.
所以, 当使用binlog时, 保证持久化是MySQL/MariaDB能从崩溃正确恢复并达成最终数据一致性的前提.&lt;/p&gt;

&lt;p&gt;MySQL/MariaDB通过XA/(binlog和存储引擎的)二段提交来保证持久化. 提交一个事务有三个步骤:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;准备阶段, 事务在存储引擎上进行持久化 ([译注] 指的可能是innoDB的undo log). 这个阶段完成后, 该事务仍可以被回滚. 如之后发生崩溃, 该事务可以被恢复.&lt;/li&gt;
&lt;li&gt;准备阶段成功后, 事务在binlog上进行持久化.&lt;/li&gt;
&lt;li&gt;最后, 提交阶段, 存储引擎将事务真正提交. 完成这步后, 事务将不可被回滚.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当系统崩溃并重启后, 恢复过程将扫描binlog. binlog中准备阶段成功但没有提交的事务将进入提交阶段. 其他准备阶段成功的事务([译注] 不在binlog中的事务)将会被回滚. 以此来保证存储引擎和binlog间的数据一致性.&lt;/p&gt;

&lt;p&gt;以上三个步骤中, 每一步骤都需要进行&lt;code&gt;fsync()&lt;/code&gt;, 相比禁用binlog时一个commit只需调用一次&lt;code&gt;fsync()&lt;/code&gt;, 这种方式比较昂贵, 使得group commit优化更为重要.&lt;/p&gt;

&lt;p&gt;不幸的是当启用binlog时, group commit在MySQL/MariaDB上不能工作! Peter Zaissev在2005年就报了这个著名的&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=13669&#34;&gt;Bug#13669&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如在开篇的图表和性能测试中所示, 我们在一个数据库服务器上跑了很多小事务(在小XtraDB表上使用REPLACE语句), 对比了启用和禁用binlog的情况. 这种性能测试的瓶颈在于持久化时&lt;code&gt;fsync()&lt;/code&gt;操作的吞吐量.&lt;/p&gt;

&lt;p&gt;我们用了两种不同的服务器来进行性能测试,一种有两块Western Digital 10k rpm HDD存储(binlog和XtraDB log写在不同的存储上); 另一种有一块Intel X25-M SSD存储. 两种服务器都运行MariaDB 5.1.44, 都开启了持久化提交, 也都关闭了存储缓存(否则测试结果将出现偏差).&lt;/p&gt;

&lt;p&gt;测试图表表明了不同数量的并发线程下的TPS. 对于每种服务器, 有一条线对应禁用binlog的情况, 另一条线对应开启binlog的情况.&lt;/p&gt;

&lt;p&gt;我们看到: 在1个运行线程时, 开启binlog会有一定性能消耗, 原因如我们所料, 是因为一次提交需要调用三次&lt;code&gt;fsync()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;更糟糕的是, 在开启binlog时group commit并不工作. 随着并发度的增加,  禁用binlog的曲线展现了良好的线性增长的性能, 但开启binlog时的性能曲线则死水一滩. 随着Group commit失效, 高并发时开启binlog的成本高的可怕(HDD存储, 64个并发线程时, 开启binlog将带来两个数量级(大于100倍)的性能损失)&lt;/p&gt;

&lt;p&gt;第一篇的结论是: 如果我们能在开启binlog时进行group commit优化, 从而解决&lt;code&gt;fsync()&lt;/code&gt;带来的性能瓶颈, 那么将获得巨大的性能提升.&lt;/p&gt;

&lt;p&gt;第二篇将深入探讨为什么开启binlog时group commit的代码会失效. 第三篇将讨论怎样修复这个bug.&lt;/p&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;第二篇&lt;/h1&gt;

&lt;p&gt;InnoDB/XtraDB是支持group commit的. group commit在&lt;code&gt;innobase_commit()&lt;/code&gt;函数中分为两部分完成: 第一部分称为&amp;rdquo;快&amp;rdquo;部分, 是在内存中准备要提交的信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trx-&amp;gt;flush_log_later = TRUE;
innobase_commit_low(trx);
trx-&amp;gt;flush_log_later = FALSE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二部分称为&amp;rdquo;慢&amp;rdquo;部分, 其调用&lt;code&gt;fsync()&lt;/code&gt;将提交信息刷磁盘.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trx_commit_complete_for_mysql(trx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个事务提交正在执行&amp;rdquo;慢&amp;rdquo;部分时, 之后提交的事务可以同时完成其&amp;rdquo;快&amp;rdquo;部分, 然后进入队列等待正在进行的&lt;code&gt;fsync()&lt;/code&gt;完成. 一旦正在进行的&lt;code&gt;fsync()&lt;/code&gt;完成, 一个新的&lt;code&gt;fsync()&lt;/code&gt;可以将队列中等待的所有事务一次刷往磁盘. 当禁用binlog时group commit就是这样工作的.&lt;/p&gt;

&lt;p&gt;当开启binlog时, Mysql用XA/二段提交来保证binlog和存储引擎间的数据一致性. 那一次commit就分为以下三个步骤:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;innobase_xa_prepare()
write() and fsync() binary log
innobase_commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是是InnoDB在&lt;code&gt;innobase_xa_prepare()&lt;/code&gt;锁住了&lt;code&gt;prepare_commit_mutex&lt;/code&gt;, 一直到&lt;code&gt;innobase_commit()&lt;/code&gt;中的&amp;rdquo;快&amp;rdquo;部分结束才释放这个锁. 这意味着当一个事务正在执行&lt;code&gt;innobase_commit()&lt;/code&gt;时, 之后提交的事务都被阻塞在&lt;code&gt;innobase_xa_prepare()&lt;/code&gt;中等待锁释放. 结果是没有事务会在队列中等待&lt;code&gt;fsync()&lt;/code&gt;, group commit因此失效.&lt;/p&gt;

&lt;p&gt;那现在的问题是开启binlog时为什么InnoDB要锁住&lt;code&gt;prepare_commit_mutex&lt;/code&gt;? 这是个非常优秀的问题, 在开展一系列调查后, 好像根本没有强有力的理由来支持这个锁的存在.&lt;/p&gt;

&lt;p&gt;无论是InnoDB代码注释, 还是bug追踪系统, 或是其它资料, 提及这个锁时都说它是用来确保在存储引擎和binlog中的提交顺序一致. 确实, 如果没有这把锁, 两个事务在存储引擎中的提交顺序是AB, 而在binlog中的顺序可能是BA.&lt;/p&gt;

&lt;p&gt;那么下一个问题是: 为什么要保证存储引擎和binlog的提交顺序一致? 目力所及的唯一原因是InnoDB热备和XtraBackup需要保证备份中的数据文件和备份中记录的binlog位置一致.&lt;/p&gt;

&lt;p&gt;Sergei Golubchik在2010 MySQL conference期间对此做了一些研究. 结论是XtraDB在获取binlog位置之前会加全局锁&lt;code&gt;FLUSH TABLE WITH READ LOCK&lt;/code&gt;, 这个锁完全阻塞所有commit, 此时可以保证数据文件和binlog位置是一致的. (InnoDB热备工具是非开源的, 但也应是相同的工作机理). 所以对于备份是不需要用&lt;code&gt;prepare_commit_mutex&lt;/code&gt;保证(非备份时)数据文件和binlog位置对齐的.&lt;/p&gt;

&lt;p&gt;另一种热备方法是LVM快照. LVM快照恢复后启动Mysql服务器, 会进入数据库恢复流程, 来确保数据文件和binlog的数据一致, 也不需要&lt;code&gt;prepare_commit_mutex&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;所以我们并不能为&lt;code&gt;prepare_commit_mutex&lt;/code&gt;的存在找到合适的理由. (然后作者在此进行了吐槽, 大意是&amp;rdquo;你们这些猪头怎么为了这么个荒谬的理由阻碍了group commit的发展?!&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;(为了实现完全的group commit, MySQL还需要做另一个修改, 就是将binlog也实现group commit)&lt;/p&gt;

&lt;p&gt;第二篇的结论是: 如果抛弃了&lt;code&gt;prepare_commit_mutex&lt;/code&gt;, MySQL可以迎来有group commit的美好时代. 第三篇将更深入进行讨论.&lt;/p&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;第三篇&lt;/h1&gt;

&lt;p&gt;这一篇将讨论如何修复group commit的问题. 如第二篇所述, 我们可以去掉&lt;code&gt;prepare_commit_mutex&lt;/code&gt;, 然后再为binlog加上独立的group commit功能, 这个问题就可以解决.&lt;/p&gt;

&lt;p&gt;然而, 我们能做的更好. 第一篇中提到, 开启binlog是我们需要XA来保证系统崩溃并恢复后存储引擎和binlog的数据最终一致性, 这种情况下1个提交需要进行3次&lt;code&gt;fsync()&lt;/code&gt;刷盘. 尽管用我们修复的group commit可以抵消一部分&lt;code&gt;fsync()&lt;/code&gt;开销, 但开销仍然很客观. 在&lt;a href=&#34;https://launchpad.net/~maria-developers&#34;&gt;maria-developers邮件列表&lt;/a&gt;中的一个&lt;a href=&#34;https://lists.launchpad.net/maria-developers/msg01998.html&#34;&gt;讨论&lt;/a&gt;中, 提到一种方法可以让3次&lt;code&gt;fsync()&lt;/code&gt;刷盘降为仅1次&lt;/p&gt;

&lt;p&gt;这个方法就是仅在为binlog刷盘时进行&lt;code&gt;fsync()&lt;/code&gt;, 也就是让&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;运行在级别2甚至级别0上.&lt;/p&gt;

&lt;p&gt;为了描述这种方法, 假设某个事务A已经写入binlog文件, &lt;code&gt;fsync()&lt;/code&gt;保证binlog文件已经刷盘. 然后事务A被提交给存储引擎, 在存储引擎将事务A刷盘前系统崩溃.&lt;/p&gt;

&lt;p&gt;系统恢复后进入数据库恢复流程, 此时事务A存在于binlog中, 但不存在于存储引擎中, 产生数据不一致. 这个不一致可以通过重放binlog中的事务A来解决. 重放binlog就像在复制的slave端所做的一样. 重放成功后, 就可以恢复成一致状态.&lt;/p&gt;

&lt;p&gt;为了能按上述步骤恢复到数据一致状态, 我们需要以下两个条件:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于一个事务, 需要将其在binlog中的位置存到存储引擎中, 这样在崩溃恢复中, 我们才能知道应从binlog哪个位置起开始回放事务.&lt;/li&gt;
&lt;li&gt;这次我们真的需要保证binlog和存储引擎的commit顺序一致! 否则崩溃恢复时, 有可能的情况是: binlog中两个事务的顺序是AB, 而存储引擎中仅有B被提交, 而A没被持久化到存储引擎中. 这样我们就没法决定如何恢复一致性了.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了确保binlog和存储引擎的提交顺序一致, 我们不能再回到&lt;code&gt;prepare_commit_mutex&lt;/code&gt;的方案了, 否则开启binlog时group commit又会失去作用. 我们将用另外的方法来确保顺序. Mark Callaghan在MySQL conference上提到了这样的方法, 可以参看&lt;a href=&#34;http://www.facebook.com/note.php?note_id=386328905932&#34;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;基本方案就是当事务被写进binlog时, 我们记住其顺序. 我们可以将事务放到一个队列里, 或者为每个事务分配单调递增的全局序号, 或者如Mark所述为每个事务分配某种ticket. 那么在&lt;code&gt;innobase_commit()&lt;/code&gt;中事务可以通过上述某种方法来保持顺序.&lt;/p&gt;

&lt;p&gt;[译注: 理论部分到此结束. 这之后都是作者在简单叙述其解决方案, 之后就不译了. 出门左转见&lt;a href=&#34;http://kristiannielsen.livejournal.com/12553.html&#34;&gt;原文&lt;/a&gt;]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试Mysql临时表的复制</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-06-12-temporary-table-replication</link>
      <pubDate>Thu, 12 Jun 2014 22:32:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-06-12-temporary-table-replication</guid>
      <description>

&lt;p&gt;测试一下Mysql 5.6.17对临时表的复制&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Percona这篇08年的blog &lt;a href=&#34;http://www.mysqlperformanceblog.com/2008/05/26/mysql-temporary-tables-safe-for-statement-based-replication/&#34;&gt;Can MySQL temporary tables be made safe for statement-based replication?&lt;/a&gt;, 是对于Mysql 5.1这方面的测试. 但根据对Mysql 5.6的相关测试, 其结论已经不适用. 其方法可供参考&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mysql Manual 对于临时表复制的&lt;a href=&#34;http://dev.mysql.com/doc/refman/5.6/en/replication-features-temptables.html&#34;&gt;讨论&lt;/a&gt;, 其中一些重要的描述列在下面:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Safe slave shutdown when using temporary tables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By default, all temporary tables are replicated; this happens whether or not there are any matching &lt;code&gt;--replicate-do-db&lt;/code&gt;, &lt;code&gt;--replicate-do-table&lt;/code&gt;, or &lt;code&gt;--replicate-wild-do-table&lt;/code&gt; options in effect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the &lt;code&gt;--replicate-ignore-table&lt;/code&gt; and &lt;code&gt;--replicate-wild-ignore-table&lt;/code&gt; options are honored for temporary tables&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;总共做了两个测试:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mysql Manual中&amp;rdquo;Safe slave shutdown when using temporary tables&amp;rdquo;一节, 验证为何需要如此安全关闭slave&lt;/li&gt;
&lt;li&gt;验证在复制临时表时, master意外crash, 是否会造成slave上的资源泄露&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个测试后都有结论&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;测试一&lt;/h2&gt;

&lt;p&gt;针对Mysql Manual提到的&amp;rdquo;Safe slave shutdown when using temporary tables&amp;rdquo;, 重现一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#准备环境, 断开复制
mysql-master&amp;gt; select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.02 sec)

mysql-slave&amp;gt; stop slave;
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#在master上构造使用临时表的两个transaction
mysql-master&amp;gt; flush logs;
Query OK, 0 rows affected (0.02 sec)

mysql-master&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql-master&amp;gt; create temporary table test.t(t int);
Query OK, 0 rows affected (0.01 sec)

mysql-master&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql-master&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql-master&amp;gt; insert into test.a select t from test.t;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql-master&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#查看master的binlog
mysql-master&amp;gt; show binlog events in &amp;quot;mysql-bin.000036&amp;quot; \G
*************************** 1. row ***************************
   Log_name: mysql-bin.000036
        Pos: 4
 Event_type: Format_desc
  Server_id: 1
End_log_pos: 120
       Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
*************************** 2. row ***************************
   Log_name: mysql-bin.000036
        Pos: 120
 Event_type: Query
  Server_id: 1
End_log_pos: 195
       Info: BEGIN
*************************** 3. row ***************************
   Log_name: mysql-bin.000036
        Pos: 195
 Event_type: Query
  Server_id: 1
End_log_pos: 301
       Info: create temporary table test.t(t int)
*************************** 4. row ***************************
   Log_name: mysql-bin.000036
        Pos: 301
 Event_type: Query
  Server_id: 1
End_log_pos: 370
       Info: COMMIT
*************************** 5. row ***************************
   Log_name: mysql-bin.000036
        Pos: 370
 Event_type: Query
  Server_id: 1
End_log_pos: 445
       Info: BEGIN
*************************** 6. row ***************************
   Log_name: mysql-bin.000036
        Pos: 445
 Event_type: Query
  Server_id: 1
End_log_pos: 554
       Info: insert into test.a select t from test.t
*************************** 7. row ***************************
   Log_name: mysql-bin.000036
        Pos: 554
 Event_type: Query
  Server_id: 1
End_log_pos: 623
       Info: COMMIT
7 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#开启复制,让复制在两个transaction之间中断

mysql-slave&amp;gt; start slave until master_log_file=&#39;mysql-bin.000036&#39;, master_log_pos=370;
Query OK, 0 rows affected, 1 warning (0.02 sec)

mysql-slave&amp;gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
...
              Master_Log_File: mysql-bin.000036
          Read_Master_Log_Pos: 623
...
        Relay_Master_Log_File: mysql-bin.000036
             Slave_IO_Running: Yes
            Slave_SQL_Running: No
...
          Exec_Master_Log_Pos: 370
...
1 row in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#查看slave正在使用的临时表, 并重启slave

mysql-slave&amp;gt; show status like &#39;%temp%&#39;;                      
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Slave_open_temp_tables | 1     |
+------------------------+-------+
1 row in set (0.01 sec)

slave&amp;gt; service mysqld restart
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#验证slave status


mysql-slave&amp;gt; show slave status\G
*************************** 1. row ***************************
...
              Master_Log_File: mysql-bin.000036
          Read_Master_Log_Pos: 623
...
        Relay_Master_Log_File: mysql-bin.000036
             Slave_IO_Running: Yes
            Slave_SQL_Running: No
...
                   Last_Errno: 1146
                   Last_Error: Error &#39;Table &#39;test.t&#39; doesn&#39;t exist&#39; on query. Default database: &#39;&#39;. Query: &#39;insert into test.a select t from test.t&#39;
...
          Exec_Master_Log_Pos: 370
...
               Last_SQL_Errno: 1146
               Last_SQL_Error: Error &#39;Table &#39;test.t&#39; doesn&#39;t exist&#39; on query. Default database: &#39;&#39;. Query: &#39;insert into test.a select t from test.t&#39;
  Replicate_Ignore_Server_Ids:
...
1 row in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;: 使用临时表时, slave并不保证crash-safe, 而且若在连续的transaction中复用同一个临时表, 完全没办法安全修复.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;测试2&lt;/h2&gt;

&lt;p&gt;对于一个&lt;code&gt;create temporary table&lt;/code&gt;, 已知&lt;code&gt;drop temporary table&lt;/code&gt;会在session结束时写进binlog. 那么如果master意外退出, 是不是会对slave造成资源泄露? 比如不释放文件句柄&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#准备master环境
mysql-master&amp;gt; select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.00 sec)

mysql-master&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#检查slave上的资源
mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 6     |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 164   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 0     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#在master上创建5张临时表
mysql-master&amp;gt; create temporary table test.t1 (t int);create temporary table test.t2 (t int);create temporary table test.t3 (t int);create temporary table test.t4 (t int);create temporary table test.t5 (t int);
Query OK, 0 rows affected (0.02 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.01 sec)

Query OK, 0 rows affected (0.01 sec)

Query OK, 0 rows affected (0.01 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#检查slave上的资源
mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 11    |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 179   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 5     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#引发master故障, 重启master库
master&amp;gt; pkill -9 mysqld
master&amp;gt; /opt/mysql/bin/mysqld_safe &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#重启slave复制, 检查slave上的资源

mysql-slave&amp;gt; stop slave io_thread;
Query OK, 0 rows affected (0.02 sec)

mysql-slave&amp;gt; start slave io_thread;
Query OK, 0 rows affected (0.00 sec)

mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 6     |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 209   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 5     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#在master上再次创建5张临时表, 检查slave上的资源
mysql-master&amp;gt; create temporary table test.t1 (t int);create temporary table test.t2 (t int);create temporary table test.t3 (t int);create temporary table test.t4 (t int);create temporary table test.t5 (t int);
Query OK, 0 rows affected (0.09 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.02 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)


mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 11    |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 224   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 10    |
...
+----------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;: 复制临时表时,slave上消耗的资源, &lt;code&gt;Innodb_num_open_files&lt;/code&gt;会及时回收,也就是说实际消耗的系统资源被及时回收. 但&lt;code&gt;Slave_open_temp_tables&lt;/code&gt;会虚高不下,按照Mysql Manual中&amp;rdquo;Safe slave shutdown when using temporary tables&amp;rdquo;的叙述, 用&lt;code&gt;Slave_open_temp_tables&lt;/code&gt;来判断关闭server的时机时, 会出现判断失误.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试Mysql临时表的binlog</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-06-12-temporary-table-binlog</link>
      <pubDate>Thu, 12 Jun 2014 22:30:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-06-12-temporary-table-binlog</guid>
      <description>

&lt;p&gt;在Mysql 5.6.17上测试临时表生成的binlog&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;测试用例&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用例&lt;/th&gt;
&lt;th&gt;row&lt;/th&gt;
&lt;th&gt;statement&lt;/th&gt;
&lt;th&gt;mixed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;create temporary table&lt;/code&gt; 产生的binlog&lt;/td&gt;
&lt;td&gt;1.1&lt;/td&gt;
&lt;td&gt;1.2&lt;/td&gt;
&lt;td&gt;1.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;create temporary table&lt;/code&gt; 产生的binlog (&lt;code&gt;mysqlbinlog&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;2.1&lt;/td&gt;
&lt;td&gt;2.2&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;临时表对非临时表数据产生影响时, 产生的binlog&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;3.2&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;临时表对非临时表数据产生影响, 并rollback时, 产生的binlog&lt;/td&gt;
&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;4.2&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;多session同时创建临时表, 产生的binlog&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;5.1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;开启&lt;code&gt;enforce-gtid-consistency&lt;/code&gt;时, &lt;code&gt;create temporary table&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;6.1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;测试结论&lt;/h2&gt;

&lt;p&gt;.1. &lt;code&gt;create temporary table&lt;/code&gt; 产生的binlog&lt;/p&gt;

&lt;p&gt;结论: 可以看到&lt;code&gt;statement&lt;/code&gt;和&lt;code&gt;mixed&lt;/code&gt;模式生成的binlog一样. 而&lt;code&gt;row&lt;/code&gt;模式中, 因为临时表并没有产生实际影响, 所以没有产生额外的binlog event&lt;/p&gt;

&lt;p&gt;.2. &lt;code&gt;create temporary table&lt;/code&gt; 产生的binlog (&lt;code&gt;mysqlbinlog&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;show binlog events&lt;/code&gt; 的输出只是摘要了binlog的内容, &lt;code&gt;mysqlbinlog&lt;/code&gt;的输出才能精准的显示binlog的内容&lt;/p&gt;

&lt;p&gt;重做&lt;code&gt;row&lt;/code&gt;模式和&lt;code&gt;statement&lt;/code&gt;模式的测试, 可以看到&lt;code&gt;row&lt;/code&gt;模式虽然不产生&lt;code&gt;create temporary table&lt;/code&gt;, 但是会产生一个&lt;code&gt;drop temporary table if exists&lt;/code&gt;; &lt;code&gt;statement&lt;/code&gt;模式产生&lt;code&gt;create temporary table&lt;/code&gt;, 但不产生&lt;code&gt;drop temporary table&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.3. 临时表对非临时表数据产生影响时, 产生的binlog&lt;/p&gt;

&lt;p&gt;可以看到&lt;code&gt;row&lt;/code&gt;模式会产生非临时表的行日志.&lt;code&gt;statement&lt;/code&gt;模式会严格记录语句.&lt;/p&gt;

&lt;p&gt;.4. 临时表对非临时表数据产生影响,并rollback时, 产生的binlog&lt;/p&gt;

&lt;p&gt;可以看到&lt;code&gt;row&lt;/code&gt;模式下, rollback不会对binlog产生影响. 在&lt;code&gt;statement&lt;/code&gt;模式下, 所有的语句都会如实反映在binlog里, 并进行rollback&lt;/p&gt;

&lt;p&gt;.5. 多session同时创建临时表, 产生的binlog&lt;/p&gt;

&lt;p&gt;不同于典型DDL, &lt;code&gt;create temporary table&lt;/code&gt;记在transaction中.&lt;/p&gt;

&lt;p&gt;由session结束产生的&lt;code&gt;drop temporary table&lt;/code&gt;则类似于典型的DDL.&lt;/p&gt;

&lt;p&gt;.6. 开启&lt;code&gt;enforce-gtid-consistency&lt;/code&gt;时, &lt;code&gt;create temporary table&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;开启&lt;code&gt;enforce-gtid-consistency&lt;/code&gt;时, 在transaction内创建临时表会得到warning:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR 1787 (HY000): When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, the statements CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can be executed in a non-transactional context only, and require that AUTOCOMMIT = 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;元日志&lt;/h2&gt;

&lt;p&gt;.1.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; set @@session.binlog_format=&amp;quot;row&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show binlog events in &#39;mysql-bin.000014&#39; \G
*************************** 1. row ***************************
   Log_name: mysql-bin.000014
        Pos: 4
 Event_type: Format_desc
  Server_id: 1
End_log_pos: 120
       Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.1.2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;

+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; set @@session.binlog_format=&amp;quot;statement&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show binlog events in &#39;mysql-bin.000015&#39; \G
*************************** 1. row ***************************
   Log_name: mysql-bin.000015
        Pos: 4
 Event_type: Format_desc
  Server_id: 1
End_log_pos: 120
       Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
*************************** 2. row ***************************
   Log_name: mysql-bin.000015
        Pos: 120
 Event_type: Query
  Server_id: 1
End_log_pos: 195
       Info: BEGIN
*************************** 3. row ***************************
   Log_name: mysql-bin.000015
        Pos: 195
 Event_type: Query
  Server_id: 1
End_log_pos: 302
       Info: create temporary table test.t (t int)
*************************** 4. row ***************************
   Log_name: mysql-bin.000015
        Pos: 302
 Event_type: Query
  Server_id: 1
End_log_pos: 371
       Info: COMMIT
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.1.3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.01 sec)

mysql&amp;gt; select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.01 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.02 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t (t int);
Query OK, 0 rows affected (0.05 sec)

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show binlog events in &#39;mysql-bin.000011&#39;\G
*************************** 1. row ***************************
   Log_name: mysql-bin.000011
        Pos: 4
 Event_type: Format_desc
  Server_id: 1
End_log_pos: 120
       Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
*************************** 2. row ***************************
   Log_name: mysql-bin.000011
        Pos: 120
 Event_type: Query
  Server_id: 1
End_log_pos: 195
       Info: BEGIN
*************************** 3. row ***************************
   Log_name: mysql-bin.000011
        Pos: 195
 Event_type: Query
  Server_id: 1
End_log_pos: 302
       Info: create temporary table test.t (t int)
*************************** 4. row ***************************
   Log_name: mysql-bin.000011
        Pos: 302
 Event_type: Query
  Server_id: 1
End_log_pos: 371
       Info: COMMIT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.2.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000014
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  4:38:58 server id 1  end_log_pos 120 CRC32 0xb935033a 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  4:38:58
# at 120
#140612  4:42:30 server id 1  end_log_pos 257 CRC32 0x8f9ccf27 	Query	thread_id=2	exec_time=0	error_code=0
SET TIMESTAMP=1402548150/*!*/;
SET @@session.pseudo_thread_id=2/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1075838976/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
DROP TEMPORARY TABLE IF EXISTS `test`.`t` /* generated by server */
/*!*/;
# at 257
#140612  4:42:51 server id 1  end_log_pos 304 CRC32 0x62766a77 	Rotate to mysql-bin.000015  pos: 4
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.2.2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000015
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  4:42:51 server id 1  end_log_pos 120 CRC32 0xc3707cb7 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  4:42:51
# Warning: this binlog is either in use or was not closed properly.
# at 120
#140612  4:42:58 server id 1  end_log_pos 195 CRC32 0x2fd0ed95 	Query	thread_id=2	exec_time=0	error_code=0
SET TIMESTAMP=1402548178/*!*/;
SET @@session.pseudo_thread_id=2/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1075838976/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
BEGIN
/*!*/;
# at 195
#140612  4:42:58 server id 1  end_log_pos 302 CRC32 0xfc742b50 	Query	thread_id=2	exec_time=0	error_code=0
SET TIMESTAMP=1402548178/*!*/;
create temporary table test.t (t int)
/*!*/;
# at 302
#140612  4:43:00 server id 1  end_log_pos 371 CRC32 0x25648832 	Query	thread_id=2	exec_time=0	error_code=0
SET TIMESTAMP=1402548180/*!*/;
COMMIT
/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.3.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; set @@session.binlog_format=&amp;quot;row&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt;  create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; insert into test.t values(2);
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows -v mysql-bin.000020
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  6:02:38 server id 1  end_log_pos 120 CRC32 0x31b6357c 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:02:38
# Warning: this binlog is either in use or was not closed properly.
# at 120
#140612  6:02:53 server id 1  end_log_pos 188 CRC32 0x23bceabc 	Query	thread_id=6	exec_time=0	error_code=0
SET TIMESTAMP=1402552973/*!*/;
SET @@session.pseudo_thread_id=6/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1075838976/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
BEGIN
/*!*/;
# at 188
#140612  6:02:53 server id 1  end_log_pos 232 CRC32 0x1a87cc74 	Table_map: `test`.`a` mapped to number 70
# at 232
#140612  6:02:53 server id 1  end_log_pos 272 CRC32 0xf0c862fb 	Write_rows: table id 70 flags: STMT_END_F
### INSERT INTO `test`.`a`
### SET
###   @1=2
# at 272
#140612  6:02:55 server id 1  end_log_pos 303 CRC32 0xb2f66e82 	Xid = 92
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.3.2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; set @@session.binlog_format=&amp;quot;statement&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; insert into test.t values(3);
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000021
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  6:07:43 server id 1  end_log_pos 120 CRC32 0xbcd985c3 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:07:43
# Warning: this binlog is either in use or was not closed properly.
# at 120
#140612  6:07:50 server id 1  end_log_pos 195 CRC32 0xf5ea27f6 	Query	thread_id=7	exec_time=0	error_code=0
SET TIMESTAMP=1402553270/*!*/;
SET @@session.pseudo_thread_id=7/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1075838976/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
BEGIN
/*!*/;
# at 195
#140612  6:07:50 server id 1  end_log_pos 302 CRC32 0xa52fbe74 	Query	thread_id=7	exec_time=0	error_code=0
SET TIMESTAMP=1402553270/*!*/;
create temporary table test.t (t int)
/*!*/;
# at 302
#140612  6:07:55 server id 1  end_log_pos 400 CRC32 0x037b8754 	Query	thread_id=7	exec_time=0	error_code=0
SET TIMESTAMP=1402553275/*!*/;
insert into test.t values(3)
/*!*/;
# at 400
#140612  6:07:59 server id 1  end_log_pos 509 CRC32 0xa1dc2124 	Query	thread_id=7	exec_time=0	error_code=0
SET TIMESTAMP=1402553279/*!*/;
insert into test.a select t from test.t
/*!*/;
# at 509
#140612  6:08:01 server id 1  end_log_pos 540 CRC32 0xf7e3aa59 	Xid = 102
COMMIT/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.4.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; set @@session.binlog_format=&amp;quot;row&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; insert into test.t values(5);
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&amp;gt; rollback;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&amp;gt; show warnings;
+---------+------+-----------------------------------------------------------------+
| Level   | Code | Message                                                         |
+---------+------+-----------------------------------------------------------------+
| Warning | 1751 | The creation of some temporary tables could not be rolled back. |
+---------+------+-----------------------------------------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000024
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  6:25:58 server id 1  end_log_pos 120 CRC32 0x8f8f4247 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:25:58
# Warning: this binlog is either in use or was not closed properly.
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.4.2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; set @@session.binlog_format=&amp;quot;statement&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t (t int);
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; insert into test.t values(4);
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; insert into test.a select t from test.t;
Query OK, 1 row affected (0.00 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&amp;gt; rollback;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&amp;gt; show warnings;
+---------+------+-----------------------------------------------------------------+
| Level   | Code | Message                                                         |
+---------+------+-----------------------------------------------------------------+
| Warning | 1751 | The creation of some temporary tables could not be rolled back. |
+---------+------+-----------------------------------------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000023
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  6:22:03 server id 1  end_log_pos 120 CRC32 0x8ebd7db6 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:22:03
# Warning: this binlog is either in use or was not closed properly.
# at 120
#140612  6:22:13 server id 1  end_log_pos 195 CRC32 0x2ef37ea7 	Query	thread_id=9	exec_time=0	error_code=0
SET TIMESTAMP=1402554133/*!*/;
SET @@session.pseudo_thread_id=9/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1075838976/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
BEGIN
/*!*/;
# at 195
#140612  6:22:13 server id 1  end_log_pos 302 CRC32 0xc642d4a1 	Query	thread_id=9	exec_time=0	error_code=0
SET TIMESTAMP=1402554133/*!*/;
create temporary table test.t (t int)
/*!*/;
# at 302
#140612  6:22:17 server id 1  end_log_pos 400 CRC32 0x076861c4 	Query	thread_id=9	exec_time=0	error_code=0
SET TIMESTAMP=1402554137/*!*/;
insert into test.t values(4)
/*!*/;
# at 400
#140612  6:22:21 server id 1  end_log_pos 509 CRC32 0x2e43db50 	Query	thread_id=9	exec_time=0	error_code=0
SET TIMESTAMP=1402554141/*!*/;
insert into test.a select t from test.t
/*!*/;
# at 509
#140612  6:22:24 server id 1  end_log_pos 580 CRC32 0xdefa8f3d 	Query	thread_id=9	exec_time=0	error_code=0
SET TIMESTAMP=1402554144/*!*/;
ROLLBACK
/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.5.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql-session1&amp;gt; set @@session.binlog_format=&amp;quot;statement&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql-session2&amp;gt; set @@session.binlog_format=&amp;quot;statement&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

mysql-session1&amp;gt; flush logs;
Query OK, 0 rows affected (0.00 sec)

mysql-session1&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql-session1&amp;gt; create temporary table test.t(t int);
Query OK, 0 rows affected (0.01 sec)

mysql-session2&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql-session2&amp;gt; create temporary table test.t(t int);
Query OK, 0 rows affected (0.02 sec)

mysql-session1&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql-session2&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql-session1&amp;gt; exit;
Bye

mysql-session2&amp;gt; exit;
Bye
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
[root@localhost data]# /opt/mysql/bin/mysqlbinlog --base64-output=decode-rows mysql-bin.000028
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 4
#140612  6:45:24 server id 1  end_log_pos 120 CRC32 0x0ad8e5a0 	Start: binlog v 4, server v 5.6.17-debug-log created 140612  6:45:24
# Warning: this binlog is either in use or was not closed properly.
# at 120
#140612  6:45:58 server id 1  end_log_pos 195 CRC32 0x59b581d0 	Query	thread_id=14	exec_time=0	error_code=0
SET TIMESTAMP=1402555558/*!*/;
SET @@session.pseudo_thread_id=14/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1075838976/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8 *//*!*/;
SET @@session.character_set_client=33,@@session.collation_connection=33,@@session.collation_server=33/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
BEGIN
/*!*/;
# at 195
#140612  6:45:58 server id 1  end_log_pos 301 CRC32 0x274004b9 	Query	thread_id=14	exec_time=0	error_code=0
SET TIMESTAMP=1402555558/*!*/;
create temporary table test.t(t int)
/*!*/;
# at 301
#140612  6:46:54 server id 1  end_log_pos 370 CRC32 0x9f2ca921 	Query	thread_id=14	exec_time=0	error_code=0
SET TIMESTAMP=1402555614/*!*/;
COMMIT
/*!*/;
# at 370
#140612  6:46:17 server id 1  end_log_pos 445 CRC32 0x3f1094c3 	Query	thread_id=16	exec_time=0	error_code=0
SET TIMESTAMP=1402555577/*!*/;
SET @@session.pseudo_thread_id=16/*!*/;
BEGIN
/*!*/;
# at 445
#140612  6:46:17 server id 1  end_log_pos 551 CRC32 0x754cae85 	Query	thread_id=16	exec_time=0	error_code=0
SET TIMESTAMP=1402555577/*!*/;
create temporary table test.t(t int)
/*!*/;
# at 551
#140612  6:46:58 server id 1  end_log_pos 620 CRC32 0x73eb6f5a 	Query	thread_id=16	exec_time=0	error_code=0
SET TIMESTAMP=1402555618/*!*/;
COMMIT
/*!*/;
# at 620
#140612  6:47:22 server id 1  end_log_pos 733 CRC32 0xb4c3b1c0 	Query	thread_id=14	exec_time=0	error_code=0
use `test`/*!*/;
SET TIMESTAMP=1402555642/*!*/;
SET @@session.pseudo_thread_id=14/*!*/;
DROP /*!40005 TEMPORARY */ TABLE IF EXISTS `t`
/*!*/;
# at 733
#140612  6:47:38 server id 1  end_log_pos 846 CRC32 0x1287fb24 	Query	thread_id=16	exec_time=0	error_code=0
SET TIMESTAMP=1402555658/*!*/;
SET @@session.pseudo_thread_id=16/*!*/;
DROP /*!40005 TEMPORARY */ TABLE IF EXISTS `t`
/*!*/;
DELIMITER ;
# End of log file
ROLLBACK /* added by mysqlbinlog */;
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.6.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@GTID_MODE;
+-------------+
| @@GTID_MODE |
+-------------+
| ON          |
+-------------+
1 row in set (0.00 sec)

mysql&amp;gt; select @@enforce_gtid_consistency;
+----------------------------+
| @@enforce_gtid_consistency |
+----------------------------+
|                          1 |
+----------------------------+
1 row in set (0.00 sec)

mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; create temporary table test.t(t int);
ERROR 1787 (HY000): When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, the statements CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can be executed in a non-transactional context only, and require that AUTOCOMMIT = 1.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>对mysql table cache的理解</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-05-15-mysql-table-cache</link>
      <pubDate>Thu, 15 May 2014 20:59:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-05-15-mysql-table-cache</guid>
      <description>

&lt;p&gt;最近读了mysql table_cache部分的一些代码.&lt;/p&gt;

&lt;p&gt;首先推荐这篇&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4673e60301010r5u.html&#34;&gt;导读&lt;/a&gt;, 写的比较详尽. 不对其中已有的部分进行重复, 仅记录自己的一些理解.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;最简单的功能&lt;/h2&gt;

&lt;p&gt;叫做table_cache, 就是对&lt;code&gt;table&lt;/code&gt;做擦车(cache).&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;table&lt;/code&gt;是指的mysql打开的表的描述结构(descriptor)(&lt;a href=&#34;http://osxr.org/mysql/source/sql/table.h#0974&#34;&gt;&lt;code&gt;TABLE&lt;/code&gt;&lt;/a&gt;),  简单理解就是mysql要操作一张表时, 就会先打开其descriptor, 打开后读取其中信息, 然后进行操作.&lt;/p&gt;

&lt;p&gt;为了快速访问, cache 往往类似于 Hash. table_cache 的 key 是
    db_name + table_name
table_cache 的 value 是 descriptor 的集合, 即 &lt;a href=&#34;http://osxr.org/mysql/source/sql/table_cache.h#0208&#34;&gt;&lt;code&gt;Table_cache_element&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;value 是 descriptor 的集合而不是 descriptor, 是因为对于同一张表, 在cache中同时会打开多个 descriptor&lt;/p&gt;

&lt;p&gt;额外一提, table_cache是按线程号分桶的, 参看&lt;code&gt;Table_cache_manager&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;进一步, 留下被回收的元素&lt;/h2&gt;

&lt;p&gt;传统擦车, 不用的元素就直接回收了. table_cache暂存了不用的元素, 提高命中率.&lt;/p&gt;

&lt;p&gt;可以看到&lt;code&gt;Table_cache_element&lt;/code&gt;一共两个列表:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;used_tables&lt;/li&gt;
&lt;li&gt;free_tables&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;进一步, 抽出共同的部分&lt;/h2&gt;

&lt;p&gt;同一张表的多个 descriptor, 会有公共部分, 抽出这些公共部分, 能有效节省资源.&lt;/p&gt;

&lt;p&gt;比如&lt;code&gt;mem_root&lt;/code&gt; (个人称之为受管内存区), 此内存区管理着跟某表相关的一些数据结构, 且受mysqld的管制. 如果同一张表的每个 descriptor 都独立管理一篇内存, 会引起不必要的浪费.&lt;/p&gt;

&lt;p&gt;抽出的公共部分称为&lt;a href=&#34;http://osxr.org/mysql/source/sql/table.h#0584&#34;&gt;&lt;code&gt;TABLE_SHARE&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;进一步, 公共部分也得擦车&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;TABLE_SHARE&lt;/code&gt; 也被擦车了, 其被回收的元素跟&lt;code&gt;TABLE&lt;/code&gt;一样也被擦车了.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;擦车的步骤&lt;/h2&gt;

&lt;p&gt;简述擦车的步骤&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在cache中查找&lt;code&gt;TABLE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果找到&lt;code&gt;TABLE&lt;/code&gt;, 则成功&lt;/li&gt;
&lt;li&gt;在cache中查找&lt;code&gt;TABLE_SHARE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果找不到&lt;code&gt;TABLE_SHARE&lt;/code&gt;, 则生成一个&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;TABLE_SHARE&lt;/code&gt;, 生成一个&lt;code&gt;TABLE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;维护好cache&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;如果找不到&lt;code&gt;TABLE_SHARE&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;参看&lt;a href=&#34;http://osxr.org/mysql/ident?_i=get_table_share_with_discover&#34;&gt;&lt;code&gt;get_table_share_with_discover&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果内存中找不到&lt;code&gt;TABLE_SHARE&lt;/code&gt;, 则向存储引擎查询, 如果存储引擎可以提供, 则进行&lt;a href=&#34;http://osxr.org/mysql/ident?_i=recover_from_failed_open&#34;&gt;discover&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;关于死锁&lt;/h2&gt;

&lt;p&gt;table_cache 里有很多代码是关于死锁的处理, 其一个主要原因是因为 mysql 分为了sql层和存储引擎层, MDL的死锁检测限于sql层, 存储引擎层自带死锁检测, 但一个死锁如果跨过两层, 则需要特殊处理&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PREVIOUS_GTIDS_LOG_EVENT的格式</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-17-PREVIOUS_GTIDS_LOG_EVENT</link>
      <pubDate>Thu, 17 Apr 2014 22:08:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-17-PREVIOUS_GTIDS_LOG_EVENT</guid>
      <description>&lt;p&gt;并没找到特别好的对&lt;code&gt;PREVIOUS_GTIDS_LOG_EVENT&lt;/code&gt;格式的描述, 自己写一个&lt;/p&gt;

&lt;p&gt;据下面这个例子, 是&lt;code&gt;mysqlbinlog&lt;/code&gt;的分析结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# at 120
#140417 15:50:36 server id 904898000  end_log_pos 311 CRC32 0x311ec069
# Position  Timestamp   Type   Master ID        Size      Master Pos    Flags
#       78 cc 87 4f 53   23   d0 a5 ef 35   bf 00 00 00   37 01 00 00   00 00
#       8b 04 00 00 00 00 00 00 00  7e 23 40 1a c6 03 11 e3 |................|
#       9b 8e 13 5e 10 e6 a0 5c fb  01 00 00 00 00 00 00 00 |................|
#       ab 01 00 00 00 00 00 00 00  06 00 00 00 00 00 00 00 |................|
#       bb 81 86 fc 1e c5 ff 11 e3  8d f9 e6 6c cf 50 db 66 |...........l.P.f|
#       cb 01 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 |................|
#       db 0c 00 00 00 00 00 00 00  a6 ce 32 8c c6 02 11 e3 |..........2.....|
#       eb 8e 0d e6 6c cf 50 db 66  01 00 00 00 00 00 00 00 |...l.P.f........|
#       fb 01 00 00 00 00 00 00 00  07 00 00 00 00 00 00 00 |................|
#      10b b7 00 99 20 c6 01 11 e3  8e 07 5e 10 e6 a0 5c fb |................|
#      11b 01 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00 |................|
#      12b 07 00 00 00 00 00 00 00  69 c0 1e 31             |........i..1|
#      Previous-GTIDs
# 7e23401a-c603-11e3-8e13-5e10e6a05cfb:1-5,
# 8186fc1e-c5ff-11e3-8df9-e66ccf50db66:1-11,
# a6ce328c-c602-11e3-8e0d-e66ccf50db66:1-6,
# b7009920-c601-11e3-8e07-5e10e6a05cfb:1-6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从78-8a的位置, 是Binlog Event header, 参看&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/binlog-event-header.html&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后四个字节, (69 c0 1e 31) 是checksum, 与参数 &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#option_mysqld_binlog-checksum&#34;&gt;binlog-checksum&lt;/a&gt; 有关&lt;/p&gt;

&lt;p&gt;中间的部分, 是gtid的数据区, 格式如下:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层次&lt;/th&gt;
&lt;th&gt;字节数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;例子中的数值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;GTID中sid-number的组数&lt;/td&gt;
&lt;td&gt;例子中为四组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;第一组sid-number的sid部分&lt;/td&gt;
&lt;td&gt;例子中为(7e 23 40 1a c6 03 11 e3 9b 8e 13 5e 10 e6 a0 5c fb)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;第一组sid-number中, internal numbers的个数&lt;/td&gt;
&lt;td&gt;例子中为1个internal number (&lt;code&gt;1-5&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;第一组sid-number中, 第一个internal number的起始number&lt;/td&gt;
&lt;td&gt;例子中为&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;第一组sid-number中, 第一个internal number的结束number+1&lt;/td&gt;
&lt;td&gt;例子中为&lt;code&gt;5+1=6&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;第一组sid-number中, 第二个internal number的起始number&lt;/td&gt;
&lt;td&gt;&amp;hellip; (例子中没有第二个internal number)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;第一组sid-number中, 第二个internal number的结束number+1&lt;/td&gt;
&lt;td&gt;&amp;hellip; (例子中没有第二个internal number)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;第二组sid-number的sid部分&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>MDL_map_partition中对锁的过渡</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-05-MDL_map_partition-lock-split</link>
      <pubDate>Sat, 05 Apr 2014 11:43:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-05-MDL_map_partition-lock-split</guid>
      <description>

&lt;p&gt;在&lt;code&gt;MDL&lt;/code&gt;源码中有一段&lt;code&gt;MDL_map_partition&lt;/code&gt;中对锁的过渡有点意思, 拿出来分析一下&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;MDL_map_partition&lt;/code&gt;是容纳&lt;code&gt;MDL_lock&lt;/code&gt;的一个容器, &lt;code&gt;MDL_lock&lt;/code&gt;可以简单的理解为一种锁.&lt;/p&gt;

&lt;p&gt;那么场景问题是现在我要从锁容器&lt;code&gt;C&lt;/code&gt;中查找一个锁&lt;code&gt;L&lt;/code&gt;并加锁&lt;code&gt;L&lt;/code&gt;, 怎样做到多线程安全&lt;/p&gt;

&lt;p&gt;场景中&lt;code&gt;C&lt;/code&gt;上有保护&lt;code&gt;C&lt;/code&gt;的锁&lt;code&gt;A&lt;/code&gt; (容器锁), &lt;code&gt;L&lt;/code&gt;上的锁为&lt;code&gt;B&lt;/code&gt; (成员锁) (此处做了简化, 实际上&lt;code&gt;MDL_lock&lt;/code&gt;并不是一个锁, 而是类似于条件变量, 而锁&lt;code&gt;B&lt;/code&gt;是保护&lt;code&gt;L&lt;/code&gt;的锁. 此处将&lt;code&gt;L&lt;/code&gt;简化为一把锁)&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;分析1&lt;/h2&gt;

&lt;p&gt;最简单的方法, 就是&lt;code&gt;A&lt;/code&gt;加锁, &lt;code&gt;B&lt;/code&gt;加锁, &lt;code&gt;A&lt;/code&gt;解锁. 这种方法肯定不会有错, 但是并发性上会出现问题. 比如以下场景&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程T1持有&lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;线程T2正在容器中查找&lt;code&gt;B&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;线程T3在同一个容器中查找另外一个&lt;code&gt;MDL_lock&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;T2先将&lt;code&gt;A&lt;/code&gt;加锁, 加锁&lt;code&gt;B&lt;/code&gt;时, 由于T1持有&lt;code&gt;B&lt;/code&gt;, T2被阻塞; T3在同一个容器中查找另一个不相关的成员, 先要加锁&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;被T2持有, T3被阻塞&lt;/p&gt;

&lt;p&gt;因此, 这种做法的并发性很差&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;分析2&lt;/h2&gt;

&lt;p&gt;提高并发性的关键是将&lt;code&gt;A&lt;/code&gt;锁过渡到&lt;code&gt;B&lt;/code&gt;锁, 比如这样: &lt;code&gt;A&lt;/code&gt;加锁, 查找&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;解锁, &lt;code&gt;B&lt;/code&gt;加锁.&lt;/p&gt;

&lt;p&gt;这种方法解决了并发性, 但显而易见形成了一个无锁区 (从&lt;code&gt;A&lt;/code&gt;解锁到&lt;code&gt;B&lt;/code&gt;加锁这个区域). 如果在无锁区另一个线程将&lt;code&gt;B&lt;/code&gt;销毁或移出容器, 那么后面的&lt;code&gt;B&lt;/code&gt;加锁操作就会悲剧&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;分析3&lt;/h2&gt;

&lt;p&gt;面对无锁区的问题, 可以试着加&lt;code&gt;version&lt;/code&gt;(版本变量)来解决, 规则如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;任何将成员移入/移出容器的情况, 都需要获得容器锁&lt;code&gt;A&lt;/code&gt;和成员锁&lt;code&gt;B&lt;/code&gt;, 并在元素&lt;code&gt;version&lt;/code&gt;上加1&lt;/li&gt;
&lt;li&gt;对成员的销毁, 需要先将成员移出容器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样, 查找成员的流程变为:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程T1, 对&lt;code&gt;A&lt;/code&gt;加锁, 找到&lt;code&gt;B&lt;/code&gt;, 记录&lt;code&gt;B&lt;/code&gt;的&lt;code&gt;version&lt;/code&gt;, 记为v1. 对&lt;code&gt;A&lt;/code&gt;解锁&lt;/li&gt;
&lt;li&gt;线程T2, &lt;code&gt;B&lt;/code&gt;销毁或移出容器, 需要获得&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;锁, 对&lt;code&gt;version&lt;/code&gt;加1, 记为v2&lt;/li&gt;
&lt;li&gt;线程T1, 等到T2释放&lt;code&gt;B&lt;/code&gt;锁后, 可获得&lt;code&gt;B&lt;/code&gt;锁, 发现&lt;code&gt;v1 != v2&lt;/code&gt;, 意味着成员可能在容器中已经被移出或销毁, 则需要重试整个过程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加入&lt;code&gt;version&lt;/code&gt;后, 对于销毁成员的场景, 并发性并没有改变 (因为仍然需要同时获得两把锁), 但对于查找成员的场景, 并发性和分析2一样&lt;/p&gt;

&lt;p&gt;不幸的是, 这个场景仍然存在问题, 很容易看到其中一个逻辑问题, T1在T2销毁&lt;code&gt;B&lt;/code&gt;锁后, 还获得了&lt;code&gt;B&lt;/code&gt;锁. 也就是T2不能即刻销毁&lt;code&gt;B&lt;/code&gt;锁, 否则所有等待&lt;code&gt;B&lt;/code&gt;锁的线程都会悲剧. 那&lt;code&gt;B&lt;/code&gt;锁何时能被安全销毁&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;分析4&lt;/h2&gt;

&lt;p&gt;要解决分析3的问题, 可以在&lt;code&gt;B&lt;/code&gt;上添加引用计数, 细节如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在成员未被移出容器时, 持有&lt;code&gt;A&lt;/code&gt;锁可以对成员引用计数&lt;code&gt;usage_count&lt;/code&gt;进行加1, 即在容器中查找成员时, 容器负责对成员的&lt;code&gt;usage_count&lt;/code&gt;加1&lt;/li&gt;
&lt;li&gt;持有&lt;code&gt;B&lt;/code&gt;锁可以对自己的解引用计数&lt;code&gt;release_count&lt;/code&gt;进行加1, 即使用者在使用完&lt;code&gt;B&lt;/code&gt;后, 对&lt;code&gt;B&lt;/code&gt;进行解引用&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;usage_count&lt;/code&gt; == &lt;code&gt;release_count&lt;/code&gt;, 则&lt;code&gt;B&lt;/code&gt;可以被安全销毁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到&lt;code&gt;usage_count&lt;/code&gt;和&lt;code&gt;release_count&lt;/code&gt;在分别在不同锁的保护下, 代入分析3的场景, 发现可以解决分析3的问题&lt;/p&gt;

&lt;p&gt;还有一些需要说明的边界情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在成员已经被移出容器后, 成员引用计数&lt;code&gt;usage_count&lt;/code&gt;不再受&lt;code&gt;A&lt;/code&gt;锁保护, 而是受&lt;code&gt;B&lt;/code&gt;锁保护. 相当于容器已经不再管理成员的引用计数&lt;/li&gt;
&lt;li&gt;如何判断&amp;rdquo;成员已经被移出容器&amp;rdquo;, 可以在成员上添加状态量&lt;code&gt;is_removed_from_container&lt;/code&gt;, 读取此状态需要&lt;code&gt;A&lt;/code&gt;锁或&lt;code&gt;B&lt;/code&gt;锁, 修改此状态需要&lt;code&gt;A&lt;/code&gt;锁和&lt;code&gt;B&lt;/code&gt;锁.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Mysql的实现&lt;/h2&gt;

&lt;p&gt;Mysql的实现和之前的分析大致相同, 给出映射表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分析里的概念&lt;/th&gt;
&lt;th&gt;Mysql的变量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;版本变量&lt;code&gt;version&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MDL_lock.m_version&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;成员引用计数&lt;code&gt;usage_count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MDL_lock.m_ref_usage&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;成员解引用计数&lt;code&gt;release_count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MDL_lock.m_ref_release&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;状态量&lt;code&gt;is_removed_from_container&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MDL_lock.m_is_destroyed&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;实现锁拆分的函数为&lt;code&gt;MDL_map_partition::move_from_hash_to_lock_mutex&lt;/code&gt;, 一看就懂&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整理一下最近读的MDL源码</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-04-MDL</link>
      <pubDate>Fri, 04 Apr 2014 20:00:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-04-MDL</guid>
      <description>

&lt;p&gt;以下都是个人理解, 如有疏漏请斧正
另, 因为理解不深, 将忽略锁级别以及锁共享的细节&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;MDL&lt;/h2&gt;

&lt;p&gt;MDL (Metadata lock), 除了正常的Condition var提供的功能外, 还额外提供了
1. 不同的锁级别. 在不冲突的情况下, 允许共享资源
2. 死锁检查和处理
3. 记录等待状态, 是死锁检查的基础&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;模型&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;MDL_lock&lt;/code&gt; 表示Mysqld中的一个资源(库/表/&amp;hellip;) 存储在全局结构 &lt;code&gt;mdl_locks (MDL_map)&lt;/code&gt;中, &lt;code&gt;mdl_locks&lt;/code&gt;内有&lt;code&gt;m_partitions&lt;/code&gt; (锁的分区), 用来分散查找lock时的竞争&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MDL_context&lt;/code&gt; 为MDL上下文接口, 表示一个资源竞争者, THD实现了这个接口, 即一个Mysqld的线程可以是&lt;code&gt;MDL_lock&lt;/code&gt;的资源竞争者&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MDL_ticket&lt;/code&gt; 表示&lt;code&gt;MDL_lock&lt;/code&gt;的许可或请求, 会同时挂在两处:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;挂在所属&lt;code&gt;MDL_Context&lt;/code&gt;中, 通过&lt;code&gt;MDL_ticket.next_in_context/prev_in_context&lt;/code&gt;组织链表&lt;/li&gt;
&lt;li&gt;挂在&lt;code&gt;MDL_lock&lt;/code&gt;的队列中, 通过&lt;code&gt;MDL_ticket.next_in_lock/prev_in_lock&lt;/code&gt;组织链表. &lt;code&gt;MDL_lock&lt;/code&gt;的队列分为两种, 一个&lt;code&gt;MDL_ticket&lt;/code&gt;可能会挂在其中之一

&lt;ul&gt;
&lt;li&gt;挂在&lt;code&gt;MDL_lock&lt;/code&gt;的等待队列(&lt;code&gt;MDL_lock.m_waiting&lt;/code&gt;)中, 表示&lt;code&gt;MDL_ticket&lt;/code&gt;的owner (&lt;code&gt;MDL_context&lt;/code&gt;)正在等待该资源(&lt;code&gt;MDL_lock&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;挂在&lt;code&gt;MDL_lock&lt;/code&gt;的已许可队列(&lt;code&gt;MDL_lock.m_granted&lt;/code&gt;)中, 表示&lt;code&gt;MDL_ticket&lt;/code&gt;的owner (&lt;code&gt;MDL_context&lt;/code&gt;)已经获得该资源(&lt;code&gt;MDL_lock&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结一下, &lt;code&gt;MDL_context&lt;/code&gt;和&lt;code&gt;MDL_ticket&lt;/code&gt;的关系是一对多, 一个竞争者可以同时申请/获得多个资源的许可; &lt;code&gt;MDL_ticket&lt;/code&gt;和&lt;code&gt;MDL_lock&lt;/code&gt;的关系是多对一, 可以同时有多个资源许可在竞争一个资源, 或者多个资源许可可以*有条件*地共享一个资源&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;如何获得锁&lt;/h2&gt;

&lt;p&gt;简单分析&lt;code&gt;MDL_context::acquire_lock&lt;/code&gt;方法, 其主要流程是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool MDL_context::acquire_lock(MDL_request *mdl_request, ulong lock_wait_timeout) {
        ...
        
        try_acquire_lock_impl(...) 
        //尝试不等待立刻获得资源, 如果成功直接返回
        //以下是等待资源的处理
        ...
        lock-&amp;gt;m_waiting.add_ticket(ticket) 
        //将一个资源申请`ticket`挂入资源`lock`的等待队列`m_waiting`
        if (lock-&amp;gt;needs_notification(ticket)) {
            //如果等待资源时需要通知状态, 则不断轮询并通知
            //将忽略此处的细节
            ...
        } else {
            //等待资源
            //结果可能是获得资源, 或者超时, 或者异常 (比如被死锁检测机制判定死亡)
            //`timed_wait`中的实现是等待COND(条件变量)`m_wait.m_COND_wait_status`
            wait_status= m_wait.timed_wait(...);
        }
        //收尾处理
        m_tickets[mdl_request-&amp;gt;duration].push_front(ticket)
        //将资源申请`ticket`挂入`MDL_Context.m_tickets`
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;记录等待状态&lt;/h2&gt;

&lt;p&gt;之前提到了记录等待状态, 在&lt;code&gt;MDL_context::acquire_lock&lt;/code&gt;方法中可以看到如下代码 (上一节未列出)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bool MDL_context::acquire_lock(MDL_request *mdl_request, ulong lock_wait_timeout) {
        m_wait.reset_status();
        ...
        will_wait_for(ticket); //其中设置了`m_waiting_for`
        if (lock-&amp;gt;needs_notification(ticket)) {
            ...
            //等待资源
            wait_status= m_wait.timed_wait(m_owner, &amp;amp;abs_timeout, TRUE,
                                      mdl_request-&amp;gt;key.get_wait_state_name());
        } else {
            //等待资源
            wait_status= m_wait.timed_wait(m_owner, &amp;amp;abs_timeout, TRUE,
                                      mdl_request-&amp;gt;key.get_wait_state_name());
        }
        done_waiting_for(); //其中清空了`m_waiting_for`
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;MDL_context.m_wait&lt;/code&gt;是用来等待资源的工具类, 其中进行等待处理, 并记录等待资源的状态/结果.&lt;/p&gt;

&lt;p&gt;还有一个&lt;code&gt;MDL_context.m_waiting_for&lt;/code&gt;也在记录&lt;code&gt;MDL_context&lt;/code&gt;正在进行的资源申请(&lt;code&gt;MDL_ticket&lt;/code&gt;), 其正在等待某个资源. 实际上&lt;code&gt;m_waiting_for&lt;/code&gt;是冗余的信息, 至于原因源代码中有解释, 此处不冗余说明&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;如何释放锁&lt;/h2&gt;

&lt;p&gt;释放锁, 需要完成下面几个动作:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;ticket&lt;/code&gt;从&lt;code&gt;MDL_lock&lt;/code&gt;的数据结构上卸下来&lt;/li&gt;
&lt;li&gt;调度选择新的锁占有者&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;ticket&lt;/code&gt;从&lt;code&gt;MDL_context&lt;/code&gt;的数据结构上卸下并回收&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;入口为&lt;code&gt;MDL_context::release_lock&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    void MDL_context::release_lock(enum_mdl_duration duration, MDL_ticket *ticket) 
    {
        ...
        lock-&amp;gt;remove_ticket(&amp;amp;MDL_lock::m_granted, ticket) {
            //将`ticket`从`MDL_lock`的数据结构上卸下来
            (this-&amp;gt;*list).remove_ticket(ticket);
            ...
            //调度选择新的锁占有者
            reschedule_waiters();
        }()
        
        //将`ticket`从`MDL_context`的数据结构上卸下并回收
        m_tickets[duration].remove(ticket);
        MDL_ticket::destroy(ticket);
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;下面说明调度的细节&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;释放锁时的调度&lt;/h2&gt;

&lt;p&gt;调度函数的入口是&lt;code&gt;MDL_lock::reschedule_waiters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最简单的调度就是从&lt;code&gt;MDL_lock.m_waiting&lt;/code&gt;队列中取出头元素, 直接将资源调度给头元素即可&lt;/p&gt;

&lt;p&gt;Mysqld在此基础上添加了一个退让条件:
如果资源连续被&lt;em&gt;高优先级&lt;/em&gt;(比如&lt;code&gt;SNW&lt;/code&gt;/&lt;code&gt;SNRW&lt;/code&gt;/&lt;code&gt;X&lt;/code&gt;锁类型)的&lt;code&gt;ticket&lt;/code&gt;获得, 那么退让一步, 允许资源间隔被调度给_低优先级_的&lt;code&gt;ticket&lt;/code&gt;防止其饿死.&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;MDL_lock::reschedule_waiters&lt;/code&gt;的代码说就是, 如果&lt;code&gt;MDL_lock&lt;/code&gt;被连续分配给&lt;code&gt;hog_lock_types_bitmap()&lt;/code&gt;中定义的_高优先级_类型的&lt;code&gt;ticket&lt;/code&gt;,连续的次数&lt;code&gt;m_hog_lock_count&lt;/code&gt;超过&lt;code&gt;max_write_lock_count&lt;/code&gt;, 那么开启退让条件, 批准第一个&lt;em&gt;非&lt;/em&gt;_高优先级_的&lt;code&gt;ticket&lt;/code&gt;获得资源&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;死锁检测&lt;/h2&gt;

&lt;p&gt;死锁检测的入口是&lt;code&gt;MDL_context::find_deadlock&lt;/code&gt;, 本身原理很简单, 但源码写的很复杂= =. 先说明原理, 再对应源码&lt;/p&gt;

&lt;p&gt;设当前&lt;code&gt;MDL_context&lt;/code&gt;为图的一个节点&lt;code&gt;A&lt;/code&gt;, 从节点&lt;code&gt;A&lt;/code&gt;出发,  找到&lt;code&gt;A&lt;/code&gt;的正在等待的资源&lt;code&gt;L&lt;/code&gt;(&lt;code&gt;A.m_waiting_for.m_lock&lt;/code&gt;)中的&lt;code&gt;m_granted&lt;/code&gt;里的每一个&lt;code&gt;MDL_ticket&lt;/code&gt;对应的&lt;code&gt;MDL_context&lt;/code&gt; &lt;code&gt;B&lt;/code&gt;, 表示&lt;code&gt;A&lt;/code&gt;正在等待&lt;code&gt;B&lt;/code&gt;释放资源&lt;code&gt;L&lt;/code&gt;. 在图中&lt;code&gt;A&lt;/code&gt; -&amp;gt; &lt;code&gt;B&lt;/code&gt; 添加一条有向边&lt;/p&gt;

&lt;p&gt;死锁检查的工作就是遍历这张有向图, 检查其是否存在环路&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;MDL_context::find_deadlock&lt;/code&gt;入口, 展开一些调用来说明代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (MDL_context::find_deadlock)
    while(1) {
        visit_subgraph(visitor) {
            m_waiting_for-&amp;gt;accept_visitor(visitor) {
                m_lock-&amp;gt;visit_subgraph(this, visitor) {
                    ...
                }()
            }()
        }()
        break if no deadlock
        set deadlock victim
        break if deadlock victim is current context
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;find_deadlock&lt;/code&gt;以&lt;code&gt;MDL_context.m_waiting_for.m_lock&lt;/code&gt;为起始点, 不断遍历其有向图, 选出victim. 直到
* 没有发现死锁
* 或自己被选为victim&lt;/p&gt;

&lt;p&gt;其使用一个visitor (&lt;code&gt;MDL_wait_for_graph_visitor&lt;/code&gt;) 贯穿遍历过程, 其记录了遍历的过程&lt;/p&gt;

&lt;p&gt;再来看&lt;code&gt;MDL_lock::visit_subgraph&lt;/code&gt;, 此函数是以一个&lt;code&gt;MDL_lock&lt;/code&gt;为起点, 来遍历依赖图&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    MDL_lock::visit_subgraph(MDL_ticket *waiting_ticket, MDL_wait_for_graph_visitor *gvisitor) {
    
        //此处是因为MDL_context.m_waiting_for是冗余信息, 但无法保证更新同步, 带来的额外操作. 忽略此处细节
        if (src_ctx-&amp;gt;m_wait.get_status() != MDL_wait::EMPTY) {...}
        
        //visitor用来记录遍历层次
        //当遍历层次大于MAX_SEARCH_DEPTH(32), 也认为发现死锁
        if (gvisitor-&amp;gt;enter_node(src_ctx)) {...}
        
        //由于现在是以一个资源(`MDL_lock`)为视角, 之后的检查为了效率, 遍历会从两个方向同时进行, 即检查节点的出度方向(`MDL_lock.m_granted`)和节点的入度方向(`MDL_lock.m_waiting`). 
        
        
        //为了效率, 死锁检测会先检测距离为1的临近节点, 而先不深度遍历图
        
        while ((ticket= granted_it++))
        {
          if (ticket-&amp;gt;get_ctx() != src_ctx &amp;amp;&amp;amp;
              ticket-&amp;gt;is_incompatible_when_granted(waiting_ticket-&amp;gt;get_type()) &amp;amp;&amp;amp;
              gvisitor-&amp;gt;inspect_edge(ticket-&amp;gt;get_ctx()))
          {
            goto end_leave_node;
          }
        }

        while ((ticket= waiting_it++))
        {
          /* Filter out edges that point to the same node. */
          if (ticket-&amp;gt;get_ctx() != src_ctx &amp;amp;&amp;amp;
              ticket-&amp;gt;is_incompatible_when_waiting(waiting_ticket-&amp;gt;get_type()) &amp;amp;&amp;amp;
              gvisitor-&amp;gt;inspect_edge(ticket-&amp;gt;get_ctx()))
          {
            goto end_leave_node;
          }
        }
        
        //此处开始, 深度遍历图
        
        granted_it.rewind();
        while ((ticket= granted_it++))
        {
          if (ticket-&amp;gt;get_ctx() != src_ctx &amp;amp;&amp;amp;
              ticket-&amp;gt;is_incompatible_when_granted(waiting_ticket-&amp;gt;get_type()) &amp;amp;&amp;amp;
              ticket-&amp;gt;get_ctx()-&amp;gt;visit_subgraph(gvisitor))
          {
            goto end_leave_node;
          }
        }
        
        waiting_it.rewind();
        while ((ticket= waiting_it++))
        {
          if (ticket-&amp;gt;get_ctx() != src_ctx &amp;amp;&amp;amp;
              ticket-&amp;gt;is_incompatible_when_waiting(waiting_ticket-&amp;gt;get_type()) &amp;amp;&amp;amp;
              ticket-&amp;gt;get_ctx()-&amp;gt;visit_subgraph(gvisitor))
          {
            goto end_leave_node;
          }
        }
        ...
        
        //visitor退栈
        gvisitor-&amp;gt;leave_node(src_ctx);
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现死锁后, 会调用&lt;code&gt;Deadlock_detection_visitor::opt_change_victim_to&lt;/code&gt;, 其中进行&lt;code&gt;MDL_context&lt;/code&gt;权重比较, 来选取一个作为victim, 此处忽略细节&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>对Mysql bug #70307 的再学习</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-01-study-mysql-bug-70307-2</link>
      <pubDate>Tue, 01 Apr 2014 13:07:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-01-study-mysql-bug-70307-2</guid>
      <description>

&lt;p&gt;之前对bug #70307有过&lt;a href=&#34;http://ikarishinjieva.github.io/blog/blog/2013/10/25/study-mysql-bug-70307/&#34;&gt;学习&lt;/a&gt;, 苦于阿兹海默状态, 又花了半天在mysql 5.5.33上探查这个场景的原因&amp;hellip;&lt;/p&gt;

&lt;p&gt;简单记录一下&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;mysql进行主从复制, 从机上&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;后, 进行&lt;code&gt;STOP SLAVE&lt;/code&gt;, 一定概率下 &lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;卡住&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;重现步骤&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;master&lt;/th&gt;
&lt;th&gt;slave client 1&lt;/th&gt;
&lt;th&gt;slave client 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;STOP SLAVE IO_THREAD&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CREATE TABLE TEST.TEST &amp;hellip;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;FLUSH TABLES WITH READ LOCK&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;START SLAVE IO_THREAD&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;STOP SLAVE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;SHOW SLAVE STATUS&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中, &lt;code&gt;START/STOP SLAVE IO_THREAD&lt;/code&gt;是为了在&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;时造成slave io_thread有未提交数据&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;死锁原因&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; 会阻塞IO_THREAD提交数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STOP SLAVE&lt;/code&gt;会等待IO_THREAD结束 (&lt;code&gt;mi-&amp;gt;stop_cond&lt;/code&gt;), 即&lt;code&gt;STOP SLAVE&lt;/code&gt;间接被&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STOP SLAVE&lt;/code&gt;在被阻塞前, 持有了&lt;code&gt;LOCK_active_mi&lt;/code&gt;, 独占了&lt;code&gt;master_info&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;会申请锁&lt;code&gt;LOCK_active_mi&lt;/code&gt;, 被&lt;code&gt;STOP SLAVE&lt;/code&gt;阻塞&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;是由之前&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;的&lt;code&gt;slave client 1&lt;/code&gt;发出的, 那逻辑上相当于自己在等待自己释放资源&lt;/li&gt;
&lt;li&gt;从另外的client上&lt;code&gt;UNLOCK TABLES&lt;/code&gt;也解不开&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>mysql, 利用假master重放binlog</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-03-26-mysql-fake-master-server</link>
      <pubDate>Wed, 26 Mar 2014 20:08:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-03-26-mysql-fake-master-server</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;这次想解决的场景是想在一个mysqld实例上重放一些来自于其他实例的binlog, 传统的方法是&lt;code&gt;mysqlbinlog&lt;/code&gt;. 但是&lt;code&gt;mysqlbinlog&lt;/code&gt;会带来一些问题, 比如这个&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=33048&#34;&gt;bug&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后同事转给我一种利用&lt;a href=&#34;http://www.orczhou.com/index.php/2013/11/use-mysql-replication-to-recove-binlog/&#34;&gt;复制重放binlog的方法&lt;/a&gt;, 其中提到两种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是修改relay log的信息, 将binlog作为relay log来放. 这是种很好的方法, 缺点是&lt;code&gt;mysqld&lt;/code&gt;需要停机重启. 如果不重启, server中对于&lt;code&gt;relay-log.index&lt;/code&gt;和&lt;code&gt;relay-log.info&lt;/code&gt;等的缓存不会刷新.&lt;/li&gt;
&lt;li&gt;第二种是起另外一个mysqld实例, 将binlog作为relay log, 再将此实例作为master, 向目标实例进行复制. 这种方式的缺点是作为中间人的mysqld实例需要消耗资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是想办法将第二种方法进行改进, 即制造一个假的master, 实现简单的复制协议, 直接将binlog复制给目标mysqld实例. 与第二种方式相比, 好处在于只使用少量资源 (一个端口, 一点用来读文件的内存).&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;实现&lt;/h2&gt;

&lt;p&gt;实现参看我的&lt;a href=&#34;https://github.com/ikarishinjieva/mysql_binlog_utils/blob/master/fake_master_server.go&#34;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意: 此实现仅适用于mysql 5.5.33, 其它版本未测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/client-server-protocol.html&#34;&gt;mysql internals&lt;/a&gt; 已经将mysql的网络协议写的比较详细, 需要做的只是起一个tcp的server, 同目标mysqld实例进行交互即可.&lt;/p&gt;

&lt;p&gt;此处逐层介绍实现, 将忽略不需要特别注意的部分. 为了简单, 将binlog的来源mysqld实例称为A, 目标mysqld实例称为B, 假master称为T.&lt;/p&gt;

&lt;p&gt;目标就是讲从A获得的binlog文件, 通过T, 在B上重放出来&lt;/p&gt;

&lt;p&gt;从B发起&lt;code&gt;start slave&lt;/code&gt;, 到T真正向B复制数据, 需要下面两个阶段&lt;/p&gt;

&lt;p&gt;.1. Handshake Phase&lt;/p&gt;

&lt;p&gt;.2. Replication Phase&lt;/p&gt;

&lt;p&gt;先介绍Handshake Phase, 有以下步骤&lt;/p&gt;

&lt;p&gt;.1.1 B执行&lt;code&gt;start slave&lt;/code&gt;, 此时B向T建立一个TCP连接&lt;/p&gt;

&lt;p&gt;.1.2 T向B发送handshake packet&lt;/p&gt;

&lt;p&gt;.1.3 B向T回复handshake packet response&lt;/p&gt;

&lt;p&gt;.1.4 T向B发送ok packet&lt;/p&gt;

&lt;p&gt;在Replication Phase, 有以下步骤&lt;/p&gt;

&lt;p&gt;.2.1 B向T查询&lt;code&gt;SELECT UNIX_TIMESTAMP()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.2.2 B向T查询&lt;code&gt;SHOW VARIABLES LIKE &#39;SERVER_ID&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.2.3 B向T执行&lt;code&gt;SET @master_heartbeat_period=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.2.4 B向T发送COM_REGISTER_SLAVE packet, 得到T回复的ok packet&lt;/p&gt;

&lt;p&gt;.2.5 B向T发送COM_BINLOG_DUMP packet, T开始向B逐一发送binlog event packet&lt;/p&gt;

&lt;p&gt;到目前为止, 所有的packet定义都可以在&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/client-server-protocol.html&#34;&gt;mysql internals&lt;/a&gt;, 逐一实现即可. 这里只简述一些处理packet时需要注意的细节.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;处理packet时需要注意的细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;所有的packet都会包装一个&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/mysql-packet.html&#34;&gt;header&lt;/a&gt;, 其中包括packet payload(不包括header)的大小, 和序号&lt;/li&gt;
&lt;li&gt;对于序号的处理, 比如2.2中B向T查询&lt;code&gt;SHOW VARIABLES LIKE &#39;SERVER_ID&#39;&lt;/code&gt;, B向T发送的第一个包序号为0, T向B回复的几个包序号依次递增为1,2,3&amp;hellip;&lt;/li&gt;
&lt;li&gt;注意数据类型, 仅整数, mysql的协议里有&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/integer.html&#34;&gt;定长整数&lt;/a&gt;和变长整数(length encoded integer), 需要特别留意packet payload的类型描述&lt;/li&gt;
&lt;li&gt;说明一下&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-COM_QUERY_Response&#34;&gt;query response packet&lt;/a&gt;. 比如B向T做一个查询, T将通过query response packet来返回查询结果. 需要说明的是, 如果查询结果为空 (比如&lt;code&gt;SET @master_heartbeat_period= ?&lt;/code&gt;的结果), 仅需返回&lt;code&gt;COM_QUERY_RESPONSE&lt;/code&gt;, 后面不需要跟着空的column定义和row数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;对超大packet的支持&lt;/h2&gt;

&lt;p&gt;当一个packet过大 (超过&lt;code&gt;1&amp;lt;&amp;lt;24-1&lt;/code&gt;byte ~= 16 MB) 时, 传输需要对packet进行切割, 参看&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意, 在A上生成binlog时, 是可以容纳大于16MB的packet的, 也就是原binlog里存在超大的event, 需要在传输时加以限制&lt;/p&gt;

&lt;p&gt;切割packet没什么特别之处, 仅需要注意包格式, 一个20MB的event的传输packet格式举例为 (此处用&lt;code&gt;16MB&lt;/code&gt;便于描述, 应为&lt;code&gt;1&amp;lt;&amp;lt;24-1&lt;/code&gt;byte):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    packet 1
        4字节 packet header
        1字节 值为[00], 是binlog event的特征标志
        16MB-1字节 为第一段数据
        
    packet 2
        4字节 packet header
        20MB-16MB+1字节 为第二段数据
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是之后的packet时不带有[00]特征位的. 而包的大小计算范围为&lt;strong&gt;除去前4字节&lt;/strong&gt;的全部字节&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;一些资料&lt;/h2&gt;

&lt;p&gt;除上文提到的资料, 还推荐&lt;a href=&#34;http://boytnt.blog.51cto.com/966121/1279318&#34;&gt;MySQL通讯协议研究系列&lt;/a&gt;, 会对包格式有个直观感觉&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Trouble shooting&lt;/h2&gt;

&lt;p&gt;在整个过程中, 有时候需要&lt;code&gt;gdb&lt;/code&gt;到&lt;code&gt;mysqld&lt;/code&gt;里来了解通讯协议的工作机制, 这里记录几个常用的函数入口点&lt;/p&gt;

&lt;p&gt;.1. slave连接到master时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  wait_for_data (fd=21, timeout=3600) at /vagrant/mysql-5.5.35/sql-common/client.c:208
    #1  0x00000000007316aa in my_connect (fd=21, name=0x7fa074004fd0, namelen=16, timeout=3600) at /vagrant/mysql-5.5.35/sql-common/client.c:187
    #2  0x00000000007363cb in mysql_real_connect (mysql=0x7fa074004960, host=0x3959cc8 &amp;quot;192.168.56.1&amp;quot;, user=0x3959d05 &amp;quot;repl&amp;quot;, passwd=0x3959d36 &amp;quot;&amp;quot;, db=0x0, port=3306, unix_socket=0x0, client_flag=2147483648)
        at /vagrant/mysql-5.5.35/sql-common/client.c:3282
    #3  0x000000000057f138 in connect_to_master (thd=0x7fa074000a40, mysql=0x7fa074004960, mi=0x3959640, reconnect=false, suppress_warnings=false) at /vagrant/mysql-5.5.35/sql/slave.cc:4297
    #4  0x000000000057edd1 in safe_connect (thd=0x7fa074000a40, mysql=0x7fa074004960, mi=0x3959640) at /vagrant/mysql-5.5.35/sql/slave.cc:4233
    #5  0x000000000057b15c in handle_slave_io (arg=0x3959640) at /vagrant/mysql-5.5.35/sql/slave.cc:2851
    #6  0x00007fa096751851 in start_thread () from /lib64/libpthread.so.0
    #7  0x00007fa0954a690d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.2. handshake phase&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  send_server_handshake_packet (mpvio=0x7fa0942eb450, data=0x391e5b4 &amp;quot;=!-\\gq$\\%&amp;gt;J8z}&#39;EgVW5&amp;quot;, data_len=21) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:8084
    #1  0x000000000059a87c in server_mpvio_write_packet (param=0x7fa0942eb450, packet=0x391e5b4 &amp;quot;=!-\\gq$\\%&amp;gt;J8z}&#39;EgVW5&amp;quot;, packet_len=21) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9082
    #2  0x000000000059bc99 in native_password_authenticate (vio=0x7fa0942eb450, info=0x7fa0942eb468) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9713
    #3  0x000000000059ad86 in do_auth_once (thd=0x391cc70, auth_plugin_name=0x1026760, mpvio=0x7fa0942eb450) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9336
    #4  0x000000000059b23a in acl_authenticate (thd=0x391cc70, connect_errors=0, com_change_user_pkt_len=0) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9472
    #5  0x00000000006d9eb5 in check_connection (thd=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:575
    #6  0x00000000006d9ffc in login_connection (thd=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:633
    #7  0x00000000006da5ba in thd_prepare_connection (thd=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:789
    #8  0x00000000006daa28 in do_handle_one_connection (thd_arg=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:855
    #9  0x00000000006da583 in handle_one_connection (arg=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:781
    #10 0x00007fa096751851 in start_thread () from /lib64/libpthread.so.0
    #11 0x00007fa0954a690d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.3. query时回复column定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  Protocol::send_result_set_metadata (this=0x3767610, list=0x3769328, flags=5)
        at /vagrant/mysql-5.5.35/sql/protocol.cc:677
    #1  0x00000000005c6745 in select_send::send_result_set_metadata (this=0x7f350c001658, list=..., flags=5)
        at /vagrant/mysql-5.5.35/sql/sql_class.cc:2132
    #2  0x000000000062895a in JOIN::exec (this=0x7f350c001678) at /vagrant/mysql-5.5.35/sql/sql_select.cc:1858
    #3  0x000000000062b2a0 in mysql_select (thd=0x37670e0, rref_pointer_array=0x3769400, tables=0x0, wild_num=0,
        fields=..., conds=0x0, og_num=0, order=0x0, group=0x0, having=0x0, proc_param=0x0, select_options=2147748608,
        result=0x7f350c001658, unit=0x3768bf8, select_lex=0x3769218) at /vagrant/mysql-5.5.35/sql/sql_select.cc:2604
    #4  0x00000000006232f5 in handle_select (thd=0x37670e0, lex=0x3768b48, result=0x7f350c001658,
        setup_tables_done_option=0) at /vagrant/mysql-5.5.35/sql/sql_select.cc:297
    #5  0x00000000005fe82d in execute_sqlcom_select (thd=0x37670e0, all_tables=0x0)
        at /vagrant/mysql-5.5.35/sql/sql_parse.cc:4627
    #6  0x00000000005f7379 in mysql_execute_command (thd=0x37670e0) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:2178
    #7  0x0000000000600a43 in mysql_parse (thd=0x37670e0, rawbuf=0x7f350c001430 &amp;quot;SELECT UNIX_TIMESTAMP()&amp;quot;, length=23,
        parser_state=0x7f35195056f0) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:5664
    #8  0x00000000005f490a in dispatch_command (command=COM_QUERY, thd=0x37670e0,
        packet=0x3770e21 &amp;quot;SELECT UNIX_TIMESTAMP()&amp;quot;, packet_length=23) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:1040
    #9  0x00000000005f3c00 in do_command (thd=0x37670e0) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:773
    #10 0x00000000006daa4b in do_handle_one_connection (thd_arg=0x37670e0)
        at /vagrant/mysql-5.5.35/sql/sql_connect.cc:862
    #11 0x00000000006da583 in handle_one_connection (arg=0x37670e0) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:781
    #12 0x00007f352e043851 in start_thread () from /lib64/libpthread.so.0
    #13 0x00007f352cd9890d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.4. query读取数据结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  cli_read_query_result (mysql=0x7f3508004960) at /vagrant/mysql-5.5.35/sql-common/client.c:3829
    #1  0x0000000000738016 in mysql_real_query (mysql=0x7f3508004960, query=0xb80e34 &amp;quot;SELECT UNIX_TIMESTAMP()&amp;quot;,
        length=23) at /vagrant/mysql-5.5.35/sql-common/client.c:3918
    #2  0x00000000005766ec in get_master_version_and_clock (mysql=0x7f3508004960, mi=0x375b400)
        at /vagrant/mysql-5.5.35/sql/slave.cc:1328
    #3  0x000000000057b35a in handle_slave_io (arg=0x375b400) at /vagrant/mysql-5.5.35/sql/slave.cc:2881
    #4  0x00007f352e043851 in start_thread () from /lib64/libpthread.so.0
    #5  0x00007f352cd9890d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.5. slave发送COM_BINLOG_DUMP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  request_dump (thd=0x7f35f80008c0, mysql=0x7f35f80076c0, mi=0x3301ac0,
        suppress_warnings=0x7f361c189e2b)
        at /vagrant/mysql-5.5.35/sql/slave.cc:2184
    #1  0x000000000057b596 in handle_slave_io (arg=0x3301ac0)
        at /vagrant/mysql-5.5.35/sql/slave.cc:2935
    #2  0x00007f3620c66851 in start_thread () from /lib64/libpthread.so.0
    #3  0x00007f361f9bb90d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>尝试使用mysql plugin将RESET SLAVE后的节点重新恢复成slave</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-02-11-try-rollback-master-back-to-slave-by-mysql-plugin</link>
      <pubDate>Tue, 11 Feb 2014 22:31:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-02-11-try-rollback-master-back-to-slave-by-mysql-plugin</guid>
      <description>

&lt;p&gt;这几天在尝试为以下场景制作一个mysql plugin, 但是是一个失败的尝试, 在此记录&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;场景&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;一对mysql主从节点 M-S, 节点S执行了RESET SLAVE
后来后悔了
在没有数据通过非replication的渠道写入S的条件下, 想让S和M重新恢复成一对主从
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键点是S能将&lt;code&gt;RESET SLAVE&lt;/code&gt;时S的&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;和&lt;code&gt;S binlog pos&lt;/code&gt;记录下来&lt;/p&gt;

&lt;p&gt;尝试了以下几种方案:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;调用者在&lt;code&gt;RESET SLAVE&lt;/code&gt;时手工记录, 不需要制作插件&lt;/h2&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Audit plugin.&lt;/h2&gt;

&lt;p&gt;Mysql的Audit plugin可以审计大部分mysqld经手的SQL, 包括&lt;code&gt;RESET SLAVE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;但Audit plugin是在每个SQL之后才会调用. 在&lt;code&gt;RESET SLAVE&lt;/code&gt;时S上master_info会被清理, 即&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;的信息在调用Audit plugin已经丢失&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Replication plugin (&lt;code&gt;after_reset_slave&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;Replication plugin (参看mysql semisync的源码), 在slave端提供了&lt;code&gt;Binlog_relay_IO_observer&lt;/code&gt;, 贴个Mysql源码方便理解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
    Observes and extends the service of slave IO thread.
 */
 typedef struct Binlog_relay_IO_observer {
   uint32 len;

   /**
      This callback is called when slave IO thread starts

      @param param Observer common parameter

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*thread_start)(Binlog_relay_IO_param *param);

   /**
      This callback is called when slave IO thread stops

      @param param Observer common parameter

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*thread_stop)(Binlog_relay_IO_param *param);

   /**
      This callback is called before slave requesting binlog transmission from master

      This is called before slave issuing BINLOG_DUMP command to master
      to request binlog.

      @param param Observer common parameter
      @param flags binlog dump flags

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*before_request_transmit)(Binlog_relay_IO_param *param, uint32 flags);

   /**
      This callback is called after read an event packet from master

      @param param Observer common parameter
      @param packet The event packet read from master
      @param len Length of the event packet read from master
      @param event_buf The event packet return after process
      @param event_len The length of event packet return after process

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*after_read_event)(Binlog_relay_IO_param *param,
                           const char *packet, unsigned long len,
                           const char **event_buf, unsigned long *event_len);

   /**
      This callback is called after written an event packet to relay log

      @param param Observer common parameter
      @param event_buf Event packet written to relay log
      @param event_len Length of the event packet written to relay log
      @param flags flags for relay log

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*after_queue_event)(Binlog_relay_IO_param *param,
                            const char *event_buf, unsigned long event_len,
                            uint32 flags);

   /**
      This callback is called after reset slave relay log IO status

      @param param Observer common parameter

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*after_reset_slave)(Binlog_relay_IO_param *param);
 } Binlog_relay_IO_observer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先尝试用&lt;code&gt;after_reset_slave&lt;/code&gt;, 从函数名字就可以看到会遇到和Audit Plugin相同的问题: 即&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;的信息在调用时已经丢失&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Replication plugin (&lt;code&gt;after_reset_slave&lt;/code&gt;再尝试, &lt;code&gt;future_group_master_log_pos&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;还不死心, &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;的数据结构是&lt;code&gt;Relay_log_info.group_master_log_pos&lt;/code&gt;, 尽管这个信息在&lt;code&gt;after_reset_slave&lt;/code&gt;时已经丢失, 但发现&lt;code&gt;Relay_log_info.future_group_master_log_pos&lt;/code&gt;可能是个方向&lt;/p&gt;

&lt;p&gt;先解释&lt;code&gt;Relay_log_info.future_group_master_log_pos&lt;/code&gt;, 可以参看&lt;code&gt;log_event.cc&lt;/code&gt;的这段注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /*
    InnoDB internally stores the master log position it has executed so far,
    i.e. the position just after the COMMIT event.
    When InnoDB will want to store, the positions in rli won&#39;t have
    been updated yet, so group_master_log_* will point to old BEGIN
    and event_master_log* will point to the beginning of current COMMIT.
    But log_pos of the COMMIT Query event is what we want, i.e. the pos of the
    END of the current log event (COMMIT). We save it in rli so that InnoDB can
    access it.
  */
  const_cast&amp;lt;Relay_log_info*&amp;gt;(rli)-&amp;gt;future_group_master_log_pos= log_pos;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;future_group_master_log_pos&lt;/code&gt;指向了execute的最后一个transaction的COMMIT event之前, 即&lt;code&gt;future_group_master_log_pos&lt;/code&gt; 大部分时间等于 &lt;code&gt;group_master_log_pos - 27&lt;/code&gt; (27是COMMIT event的长度)&lt;/p&gt;

&lt;p&gt;但仍有例外情况: 如果M执行了&lt;code&gt;FLUSH LOGS&lt;/code&gt;, 将log从0001递增到了0002, 此时S上的&lt;code&gt;future_group_master_log_pos&lt;/code&gt;会指向0001的最后一个transaction的COMMIT event之前. 但S上的&lt;code&gt;group_master_log_name&lt;/code&gt;已经到了0002, 与&lt;code&gt;future_group_master_log_pos&lt;/code&gt;不匹配, 会引起异常&lt;/p&gt;

&lt;p&gt;(其实此时S上的&lt;code&gt;group_master_log_name&lt;/code&gt;也已经置空了, 但可以从内存残片中恢复出文件名)&lt;/p&gt;

&lt;p&gt;设想如果对于log_name也有&lt;code&gt;future_group_master_log_name&lt;/code&gt;, 那么S可以直接&lt;code&gt;change master&lt;/code&gt;到M的&lt;code&gt;future_group_master_log_name&lt;/code&gt;和&lt;code&gt;future_group_master_log_pos&lt;/code&gt;位置, 可以恢复起M-S主从结构&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Replication plugin (&lt;code&gt;thread_stop&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;Replication plugin的&lt;code&gt;thread_stop&lt;/code&gt;是指Slave IO thread停止时调用, 此时可以拿到&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;和&lt;code&gt;S binlog pos&lt;/code&gt;, 但拿到的&lt;code&gt;S binlog pos&lt;/code&gt;没有意义, 因为不能保证Slave SQL thread也停下来了&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Storage Engine plugin&lt;/h2&gt;

&lt;p&gt;这是我最后一根救命稻草, 阅读Mysql源码时注意到以下片段(做了缩减)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int reset_slave(THD *thd, Master_info* mi)
{
    ...
    ha_reset_slave(thd);
    ... //clean memory data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;reset_slave&lt;/code&gt;在清理内存数据前通知了storage engine插件, 这个插件可以获得所有必要信息&lt;/p&gt;

&lt;p&gt;但存在一个问题, 即&lt;code&gt;ha_reset_slave&lt;/code&gt;仅在Mysql NDB版本中存在, 不具备通用性, 参看宏定义(做了缩减)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_NDB_BINLOG
...
void ha_reset_slave(THD *thd);
...
#else
...
#define ha_reset_slave(a) do {} while (0)
...
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;吐槽和总结&lt;/h2&gt;

&lt;p&gt;可以看到Mysql plugin不&lt;strong&gt;太&lt;/strong&gt;预留接口, 是仅仅为已知应用场景提供必要接口, 比如&lt;code&gt;Binlog_relay_IO_observer&lt;/code&gt;中有&lt;code&gt;after&lt;/code&gt;不一定有&lt;code&gt;before&lt;/code&gt;. 比较容易控制插件质量, 但插件能做到的非常局限.&lt;/p&gt;

&lt;p&gt;以上各种尝试, 归根到底, 只要修改Mysql的一点源码编译一下就可以达到很好的效果, 不需要用插件的方式在Mysql中到处找功能插槽, 但通用性变差.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>