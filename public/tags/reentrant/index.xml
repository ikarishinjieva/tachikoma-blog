<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Reentrant on Tachikoma blog </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://ikarishinjieva.github.io/tags/reentrant/index.xml</link>
    <language>zh-cn</language>
    
    
    <updated>Thu, 14 Mar 2013 21:37:00 UTC</updated>
    
    <item>
      <title>读写锁-读可重入</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/%E8%AF%BB%E5%86%99%E9%94%81-%E8%AF%BB%E5%8F%AF%E9%87%8D%E5%85%A5/</link>
      <pubDate>Thu, 14 Mar 2013 21:37:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/%E8%AF%BB%E5%86%99%E9%94%81-%E8%AF%BB%E5%8F%AF%E9%87%8D%E5%85%A5/</guid>
      <description>&lt;p&gt;发现&lt;a href=&#34;http://tutorials.jenkov.com/java-concurrency/read-write-locks.html&#34;&gt;这篇文献&lt;/a&gt;描写读写锁和可重入性非常具体。&lt;/p&gt;

&lt;p&gt;尝试实现文章中的读可重入的读写锁：&lt;/p&gt;

&lt;p&gt;考虑如何测试一个读可重入的读写锁, 由于读写锁的性质(可以同时存在多个读锁), 如果只是在线程A连续申请两个读锁, 就无法证明是锁的重入性发挥了作用。&lt;/p&gt;

&lt;p&gt;测试思路是先在线程A申请读锁, 然后在线程B申请写锁, 若在线程C申请读锁, 此读锁应阻塞。而如果在线程A申请另一个读锁(前一个未释放), 线程A不应被阻塞。&lt;/p&gt;

&lt;p&gt;测试代码(我的确用了Main来测试&amp;hellip;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws InterruptedException {
    final ReadWriteLockReadReentrant lock = new ReadWriteLockReadReentrant();

    new Thread() {
        @Override
        public void run() {
            try {
                lock.lockRead();
                System.out.println(&amp;quot;Reading&amp;quot;);
                sleep(5000);
                System.out.println(&amp;quot;Inner Reading&amp;quot;);
                lock.lockRead();
            } catch (InterruptedException e) {

            } finally {
                System.out.println(&amp;quot;Inner Reading End&amp;quot;);
                lock.unlockRead();
                System.out.println(&amp;quot;Reading End&amp;quot;);
                lock.unlockRead();
            }
        }
    }.start();
    Thread.sleep(500);
    
    new Thread() {
        @Override
        public void run() {
            try {
                System.out.println(&amp;quot;Request write lock&amp;quot;);
                lock.lockWrite();
                System.out.println(&amp;quot;Writing&amp;quot;);
            } catch (InterruptedException e) {

            } finally {
                System.out.println(&amp;quot;Writing End&amp;quot;);
                lock.unlockWrite();
            }
        }
    }.start();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果应当是：Reading(线程A),Request write lock(线程B),Inner Reading(未阻塞),Inner Reading End,Reading End,Writing,Writing End&lt;/p&gt;

&lt;p&gt;读重入的读写锁(基本是抄上面文献的代码~)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.util.HashMap;
import java.util.Map;

public class ReadWriteLockReadReentrant {
    private boolean hasWriter = false;
    private int writeRequests = 0;
    private Map&amp;lt;Thread, Integer&amp;gt; readers = new HashMap&amp;lt;Thread, Integer&amp;gt;();

    public synchronized void lockRead() throws InterruptedException {
        Thread current = Thread.currentThread();
        while (!couldRead(current)) {
            wait();
        }
        readers.put(current, getReaders(current) + 1);
    }

    private int getReaders(Thread current) {
        if (!readers.containsKey(current)) {
            return 0;
        }
        return readers.get(current);
    }

    private boolean couldRead(Thread current) {
        if (hasWriter) {
            return false;
        }
        if (readers.containsKey(current)) {
            return true; //important
        }
        if (writeRequests &amp;gt; 0) {
            return false;
        }
        return true;
    }

    public synchronized void unlockRead() {
        Thread current = Thread.currentThread();
        setReaders(current, getReaders(current) - 1);
        notifyAll();
    }

    private void setReaders(Thread current, Integer now) {
        if (now == 0) {
            readers.remove(current);
        } else {
            readers.put(current, now);
        }
    }

    public synchronized void lockWrite() throws InterruptedException {
        writeRequests++;
        while (readers.size() &amp;gt; 0) {
            wait();
        }
        writeRequests--;
        hasWriter = true;
    }


    public synchronized void unlockWrite() {
        hasWriter = false;
        notifyAll();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是标记&amp;rdquo;//important&amp;rdquo;的那行，如果这个判断和writeRequest的判断互换位置，线程B申请写锁被阻塞时，线程A无法申请到第二个读锁。一切就悲剧了。&lt;/p&gt;

&lt;p&gt;标记为&amp;rdquo;//important&amp;rdquo;的判断和writeRequest的判断互换位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean couldRead(Thread current) {
    if (hasWriter) {
        return false;
    }
    if (writeRequests &amp;gt; 0) {
        return false;
    }
    if (readers.containsKey(current)) {
        return true; //important
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>