<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Replication on Tachikoma blog </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://ikarishinjieva.github.io/tachikoma-blog/tags/replication/index.xml/</link>
    <language>zh-cn</language>
    
    
    <updated>Thu, 13 Nov 2014 19:44:00 UTC</updated>
    
    <item>
      <title>Mysql 出现ER_GTID_NEXT_TYPE_UNDEFINED_GROUP的第三种可能</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-11-13-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP-3</link>
      <pubDate>Thu, 13 Nov 2014 19:44:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-11-13-mysql-ER_GTID_NEXT_TYPE_UNDEFINED_GROUP-3</guid>
      <description>&lt;p&gt;之前讨论过两种出现ER_GTID_NEXT_TYPE_UNDEFINED_GROUP的可能(&lt;a href=&#34;http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-05-mysql-er_gtid_next_type_undefined_group/&#34;&gt;可能1&lt;/a&gt;和&lt;a href=&#34;http://ikarishinjieva.github.io/tachikoma-blog/post/2014-09-17-mysql-er_gtid_next_type_undefined_group-2/&#34;&gt;可能2&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;但都不是之前在线上环境见到的状况, 前几天QA重现了线上的情况, 经过几天的折腾, 终于找到了原因.&lt;/p&gt;

&lt;p&gt;###结论&lt;/p&gt;

&lt;p&gt;先说结论, Mysql 5.6.21以下的Mysql版本会出现这个错误, 导致复制不正常, 发生&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;错误, 而如果强行&lt;code&gt;start slave&lt;/code&gt;, 会永久丢失一个事务, 导致主从数据不一致.&lt;/p&gt;

&lt;p&gt;这个错误的发生概率还是较大的, 如果使用了GTID, 并且使用了&lt;code&gt;master_auto_position&lt;/code&gt;来建立复制, 那建议升级到Mysql 5.6.21.&lt;/p&gt;

&lt;p&gt;###如何重现&lt;/p&gt;

&lt;p&gt;先用下面的patch修改Mysql源码, 这段patch用于增加debug点 (如果不想修改源码, 也可用gdb手工模仿):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--- rpl_slave.cc.orig     2014-11-12 16:03:36.000000000 +0800
+++ rpl_slave.cc     2014-11-12 16:05:18.000000000 +0800
@@ -4378,6 +4378,14 @@
       THD_STAGE_INFO(thd, stage_queueing_master_event_to_the_relay_log);
       event_buf= (const char*)mysql-&amp;gt;net.read_pos + 1;
       DBUG_PRINT(&amp;quot;info&amp;quot;, (&amp;quot;IO thread received event of type %s&amp;quot;, Log_event::get_type_str((Log_event_type)event_buf[EVENT_TYPE_OFFSET])));
+
+      DBUG_EXECUTE_IF(&amp;quot;stop_io_before_reading_xid_log_event&amp;quot;,
+        if (event_buf[EVENT_TYPE_OFFSET] == XID_EVENT) {
+           thd-&amp;gt;killed= THD::KILLED_NO_VALUE;
+           goto err;
+        }
+      );
+
       if (RUN_HOOK(binlog_relay_io, after_read_event,
                    (thd, mi,(const char*)mysql-&amp;gt;net.read_pos + 1,
                     event_len, &amp;amp;event_buf, &amp;amp;event_len)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行下面的mysql-test脚本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--source include/have_debug.inc
--source include/have_gtid.inc

--disable_warnings
--source include/master-slave.inc
--enable_warnings

--connection master
create table test.a(a int) engine=innodb;
flush logs;
--source include/sync_slave_sql_with_master.inc

--connection slave
stop slave;
set global debug=&amp;quot;d,stop_io_before_reading_xid_log_event&amp;quot;;

--connection master
begin;
insert into test.a values(1);
insert into test.a values(2);
commit;

--connection slave
start slave io_thread;
--let $slave_param= Slave_IO_Running
--let $slave_param_value= No
--source include/wait_for_slave_param.inc

--connection slave
set global debug=&amp;quot;&amp;quot;;

start slave;
--let $slave_param= Slave_SQL_Running
--let $slave_param_value= No
--source include/wait_for_slave_param.inc

--let $errno= query_get_value(&amp;quot;SHOW SLAVE STATUS&amp;quot;, &amp;quot;Last_Errno&amp;quot;, 1)
--if ($errno != &amp;quot;1837&amp;quot;) {
    --echo Got unexpect errno=$errno
    --die
}
--echo Got Slave SQL error 1837

# Cleanup
--connection master
drop table test.a;

--connection slave
set global debug=&amp;quot;&amp;quot;;
start slave;
--source include/sync_slave_sql_with_master.inc
--source include/rpl_end.inc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Mysql 5.6.&lt;sup&gt;19&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;.6.20上都能成功重现.&lt;/p&gt;

&lt;p&gt;###Bug分析&lt;/p&gt;

&lt;p&gt;重现这个bug需要具备以下前提条件:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mysql使用GTID&lt;/li&gt;
&lt;li&gt;Mysql复制使用了&lt;code&gt;master_auto_position&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对重现的每个步骤进行说明:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先需要在Master上进行&lt;code&gt;flush logs&lt;/code&gt;, 这样生成的binlog和一般binlog的区别是&lt;code&gt;created&lt;/code&gt;段值为0 (&lt;strong&gt;正常的binlog rotate也会产生这个效果&lt;/strong&gt;). 关于&lt;code&gt;created&lt;/code&gt;在Mysql源码中是如下说明的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
If this event is at the start of the first binary log since server
startup &#39;created&#39; should be the timestamp when the event (and the
binary log) was created.  In the other case (i.e. this event is at
the start of a binary log created by FLUSH LOGS or automatic
rotation), &#39;created&#39; should be 0.  This &amp;quot;trick&amp;quot; is used by MySQL
&amp;gt;=4.0.14 slaves to know whether they must drop stale temporary
tables and whether they should abort unfinished transaction.
...
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额外一提, &lt;code&gt;mysqlbinlog&lt;/code&gt;在解析binlog时对&lt;code&gt;created&lt;/code&gt;段解析是有问题的, 建议直接使用&lt;code&gt;mysqlbinlog --hexdump&lt;/code&gt;来看&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;然后在Slave上设置新加的debug点&lt;code&gt;stop_io_before_reading_xid_log_event&lt;/code&gt;, 并开启IO复制线程.&lt;/p&gt;

&lt;p&gt;在Master上插入以下事务:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin;
insert into test.a values(1);
insert into test.a values(2);
commit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样IO复制线程会在commit之前停下来, 假设正在使用relay-log.000001, 那这个relay log中就只含有begin和两个insert&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下来去掉debug点,再次开启IO复制线程.&lt;/p&gt;

&lt;p&gt;由于Mysql复制使用了&lt;code&gt;master_auto_position&lt;/code&gt;(前提条件2), 就会重传整个事务, 得到以下的relay log:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---relay-log.000001
...
GTID
begin;
insert into test.a values(1);
insert into test.a values(2);
ROTATE

--relay-log.000002
slave FDE (Format_description_event)
Previous-gtid
Rotate
master FDE (created=0)
Rotate&#39;
Rotate&#39;&#39;
GTID
begin;
insert into test.a values(1);
insert into test.a values(2);
commit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两点说明:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果不使用&lt;code&gt;master_auto_position&lt;/code&gt;, 就不会重传整个事务, 而是断点续传&lt;/li&gt;
&lt;li&gt;relay-log.000002开头好几个rotate看起来比较复杂, 可以先忽略这个细节, 对整个bug没有影响
得到上面的relay-log后, 如果开启sql线程会发生什么呢?&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;如果之前没有将&lt;code&gt;created&lt;/code&gt;段置为0的那一步, 一切运行都会是正常的, 原因是在master FDE的处理中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Format_description_log_event::do_apply_event
  /*
    As a transaction NEVER spans on 2 or more binlogs:
    if we have an active transaction at this point, the master died
    while writing the transaction to the binary log, i.e. while
    flushing the binlog cache to the binlog. XA guarantees that master has
    rolled back. So we roll back.
    Note: this event could be sent by the master to inform us of the
    format of its binlog; in other words maybe it is not at its
    original place when it comes to us; we&#39;ll know this by checking
    log_pos (&amp;quot;artificial&amp;quot; events have log_pos == 0).
  */
  if (!is_artificial_event() &amp;amp;&amp;amp; created &amp;amp;&amp;amp; thd-&amp;gt;transaction.all.ha_list)
  {
    /* This is not an error (XA is safe), just an information */
    rli-&amp;gt;report(INFORMATION_LEVEL, 0,
                &amp;quot;Rolling back unfinished transaction (no COMMIT &amp;quot;
                &amp;quot;or ROLLBACK in relay log). A probable cause is that &amp;quot;
                &amp;quot;the master died while writing the transaction to &amp;quot;
                &amp;quot;its binary log, thus rolled back too.&amp;quot;); 
    const_cast&amp;lt;Relay_log_info*&amp;gt;(rli)-&amp;gt;cleanup_context(thd, 1);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前存在事务(&lt;code&gt;thd-&amp;gt;transaction.all.ha_list&lt;/code&gt;), 且master FDE标明它是master启动时产生的binlog, 那slave会将当前事务回滚掉(&lt;code&gt;cleanup_context&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;如果master在写入binlog时崩溃, master重启后会回滚binlog,那slave也会相应产生回滚.&lt;/p&gt;

&lt;p&gt;由于我们之前设置了&lt;code&gt;created&lt;/code&gt;为0, 这个机制就不起作用. 之后会发生什么呢?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;sql线程是这样执行的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从relay-log.000001往下执行, 进入事务&lt;/li&gt;
&lt;li&gt;发现Rotate, 轮换到relay-log.000002, 但事务并没有结束, 就仿佛一个事务跨了两个relay log(一个事务是可以跨多个relay log)&lt;/li&gt;
&lt;li&gt;master FDE的保护机制由于FDE的&lt;code&gt;created&lt;/code&gt;为0而失效, 可以继续执行, 且仍在事务中&lt;/li&gt;
&lt;li&gt;GTID event将当前线程的&lt;code&gt;GTID_NEXT&lt;/code&gt;值重置, 但&lt;strong&gt;并不会回滚事务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BEGIN event会将当前事务提交, 清掉&lt;code&gt;GTID_NEXT&lt;/code&gt;, 并开始新的事务&lt;/li&gt;
&lt;li&gt;之后的insert发现&lt;code&gt;GTID_NEXT&lt;/code&gt;已经为空, 故报了&lt;code&gt;ER_GTID_NEXT_TYPE_UNDEFINED_GROUP&lt;/code&gt;的错误&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;需要说明一下BEGIN event为什么会提交事务. 这也很好理解, 如果执行下面的语句:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN;
insert into test.a values(444);
BEGIN;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Mysql中正常的流程是insert会被隐式提交. 但在执行relay log时, 这样的处理就会导致新的事务丢失了GTID事件.&lt;/p&gt;

&lt;p&gt;###Mysql 5.6.21的修复&lt;/p&gt;

&lt;p&gt;之前我们提到了: GTID event将当前线程的&lt;code&gt;GTID_NEXT&lt;/code&gt;值重置, 但&lt;strong&gt;并不会回滚事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而Mysql 5.6.21进行的修复就是让GTID event进行事务回滚, 代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Gtid_log_event::do_apply_event
if (thd-&amp;gt;owned_gtid.sidno)
{
    /*
      Slave will execute this code if a previous Gtid_log_event was applied
      but the GTID wasn&#39;t consumed yet (the transaction was not committed
      nor rolled back).
      On a client session we cannot do consecutive SET GTID_NEXT without
      a COMMIT or a ROLLBACK in the middle.
      Applying this event without rolling back the current transaction may
      lead to problems, as a &amp;quot;BEGIN&amp;quot; event following this GTID will
      implicitly commit the &amp;quot;partial transaction&amp;quot; and will consume the
      GTID. If this &amp;quot;partial transaction&amp;quot; was left in the relay log by the
      IO thread restarting in the middle of a transaction, you could have
      the partial transaction being logged with the GTID on the slave,
      causing data corruption on replication.
    */
    if (thd-&amp;gt;transaction.all.ha_list)
    {
      /* This is not an error (XA is safe), just an information */
      rli-&amp;gt;report(INFORMATION_LEVEL, 0,
                  &amp;quot;Rolling back unfinished transaction (no COMMIT &amp;quot;
                  &amp;quot;or ROLLBACK in relay log). A probable cause is partial &amp;quot;
                  &amp;quot;transaction left on relay log because of restarting IO &amp;quot;
                  &amp;quot;thread with auto-positioning protocol.&amp;quot;);
      const_cast&amp;lt;Relay_log_info*&amp;gt;(rli)-&amp;gt;cleanup_context(thd, 1);
    }
    gtid_rollback(thd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;gtid_rollback&lt;/code&gt;是在之前版本中就有, 是用来回滚GTID信息的. 而&lt;code&gt;if (thd-&amp;gt;transaction.all.ha_list)&lt;/code&gt;中的是Mysql 5.6.21的修复部分.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试Mysql临时表的复制</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-06-12-temporary-table-replication</link>
      <pubDate>Thu, 12 Jun 2014 22:32:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-06-12-temporary-table-replication</guid>
      <description>

&lt;p&gt;测试一下Mysql 5.6.17对临时表的复制&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Percona这篇08年的blog &lt;a href=&#34;http://www.mysqlperformanceblog.com/2008/05/26/mysql-temporary-tables-safe-for-statement-based-replication/&#34;&gt;Can MySQL temporary tables be made safe for statement-based replication?&lt;/a&gt;, 是对于Mysql 5.1这方面的测试. 但根据对Mysql 5.6的相关测试, 其结论已经不适用. 其方法可供参考&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mysql Manual 对于临时表复制的&lt;a href=&#34;http://dev.mysql.com/doc/refman/5.6/en/replication-features-temptables.html&#34;&gt;讨论&lt;/a&gt;, 其中一些重要的描述列在下面:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Safe slave shutdown when using temporary tables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By default, all temporary tables are replicated; this happens whether or not there are any matching &lt;code&gt;--replicate-do-db&lt;/code&gt;, &lt;code&gt;--replicate-do-table&lt;/code&gt;, or &lt;code&gt;--replicate-wild-do-table&lt;/code&gt; options in effect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the &lt;code&gt;--replicate-ignore-table&lt;/code&gt; and &lt;code&gt;--replicate-wild-ignore-table&lt;/code&gt; options are honored for temporary tables&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;总共做了两个测试:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mysql Manual中&amp;rdquo;Safe slave shutdown when using temporary tables&amp;rdquo;一节, 验证为何需要如此安全关闭slave&lt;/li&gt;
&lt;li&gt;验证在复制临时表时, master意外crash, 是否会造成slave上的资源泄露&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个测试后都有结论&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;测试一&lt;/h2&gt;

&lt;p&gt;针对Mysql Manual提到的&amp;rdquo;Safe slave shutdown when using temporary tables&amp;rdquo;, 重现一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#准备环境, 断开复制
mysql-master&amp;gt; select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.02 sec)

mysql-slave&amp;gt; stop slave;
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#在master上构造使用临时表的两个transaction
mysql-master&amp;gt; flush logs;
Query OK, 0 rows affected (0.02 sec)

mysql-master&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql-master&amp;gt; create temporary table test.t(t int);
Query OK, 0 rows affected (0.01 sec)

mysql-master&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)

mysql-master&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql-master&amp;gt; insert into test.a select t from test.t;
Query OK, 0 rows affected (0.00 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql-master&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#查看master的binlog
mysql-master&amp;gt; show binlog events in &amp;quot;mysql-bin.000036&amp;quot; \G
*************************** 1. row ***************************
   Log_name: mysql-bin.000036
        Pos: 4
 Event_type: Format_desc
  Server_id: 1
End_log_pos: 120
       Info: Server ver: 5.6.17-debug-log, Binlog ver: 4
*************************** 2. row ***************************
   Log_name: mysql-bin.000036
        Pos: 120
 Event_type: Query
  Server_id: 1
End_log_pos: 195
       Info: BEGIN
*************************** 3. row ***************************
   Log_name: mysql-bin.000036
        Pos: 195
 Event_type: Query
  Server_id: 1
End_log_pos: 301
       Info: create temporary table test.t(t int)
*************************** 4. row ***************************
   Log_name: mysql-bin.000036
        Pos: 301
 Event_type: Query
  Server_id: 1
End_log_pos: 370
       Info: COMMIT
*************************** 5. row ***************************
   Log_name: mysql-bin.000036
        Pos: 370
 Event_type: Query
  Server_id: 1
End_log_pos: 445
       Info: BEGIN
*************************** 6. row ***************************
   Log_name: mysql-bin.000036
        Pos: 445
 Event_type: Query
  Server_id: 1
End_log_pos: 554
       Info: insert into test.a select t from test.t
*************************** 7. row ***************************
   Log_name: mysql-bin.000036
        Pos: 554
 Event_type: Query
  Server_id: 1
End_log_pos: 623
       Info: COMMIT
7 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#开启复制,让复制在两个transaction之间中断

mysql-slave&amp;gt; start slave until master_log_file=&#39;mysql-bin.000036&#39;, master_log_pos=370;
Query OK, 0 rows affected, 1 warning (0.02 sec)

mysql-slave&amp;gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
...
              Master_Log_File: mysql-bin.000036
          Read_Master_Log_Pos: 623
...
        Relay_Master_Log_File: mysql-bin.000036
             Slave_IO_Running: Yes
            Slave_SQL_Running: No
...
          Exec_Master_Log_Pos: 370
...
1 row in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#查看slave正在使用的临时表, 并重启slave

mysql-slave&amp;gt; show status like &#39;%temp%&#39;;                      
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Slave_open_temp_tables | 1     |
+------------------------+-------+
1 row in set (0.01 sec)

slave&amp;gt; service mysqld restart
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#验证slave status


mysql-slave&amp;gt; show slave status\G
*************************** 1. row ***************************
...
              Master_Log_File: mysql-bin.000036
          Read_Master_Log_Pos: 623
...
        Relay_Master_Log_File: mysql-bin.000036
             Slave_IO_Running: Yes
            Slave_SQL_Running: No
...
                   Last_Errno: 1146
                   Last_Error: Error &#39;Table &#39;test.t&#39; doesn&#39;t exist&#39; on query. Default database: &#39;&#39;. Query: &#39;insert into test.a select t from test.t&#39;
...
          Exec_Master_Log_Pos: 370
...
               Last_SQL_Errno: 1146
               Last_SQL_Error: Error &#39;Table &#39;test.t&#39; doesn&#39;t exist&#39; on query. Default database: &#39;&#39;. Query: &#39;insert into test.a select t from test.t&#39;
  Replicate_Ignore_Server_Ids:
...
1 row in set (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;: 使用临时表时, slave并不保证crash-safe, 而且若在连续的transaction中复用同一个临时表, 完全没办法安全修复.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;测试2&lt;/h2&gt;

&lt;p&gt;对于一个&lt;code&gt;create temporary table&lt;/code&gt;, 已知&lt;code&gt;drop temporary table&lt;/code&gt;会在session结束时写进binlog. 那么如果master意外退出, 是不是会对slave造成资源泄露? 比如不释放文件句柄&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#准备master环境
mysql-master&amp;gt; select @@binlog_format;
+-----------------+
| @@binlog_format |
+-----------------+
| MIXED           |
+-----------------+
1 row in set (0.00 sec)

mysql-master&amp;gt; select @@gtid_mode;
+-------------+
| @@gtid_mode |
+-------------+
| OFF         |
+-------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#检查slave上的资源
mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 6     |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 164   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 0     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#在master上创建5张临时表
mysql-master&amp;gt; create temporary table test.t1 (t int);create temporary table test.t2 (t int);create temporary table test.t3 (t int);create temporary table test.t4 (t int);create temporary table test.t5 (t int);
Query OK, 0 rows affected (0.02 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.01 sec)

Query OK, 0 rows affected (0.01 sec)

Query OK, 0 rows affected (0.01 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#检查slave上的资源
mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 11    |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 179   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 5     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#引发master故障, 重启master库
master&amp;gt; pkill -9 mysqld
master&amp;gt; /opt/mysql/bin/mysqld_safe &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#重启slave复制, 检查slave上的资源

mysql-slave&amp;gt; stop slave io_thread;
Query OK, 0 rows affected (0.02 sec)

mysql-slave&amp;gt; start slave io_thread;
Query OK, 0 rows affected (0.00 sec)

mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 6     |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 209   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 5     |
...
+----------------------------+-------+
14 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;#在master上再次创建5张临时表, 检查slave上的资源
mysql-master&amp;gt; create temporary table test.t1 (t int);create temporary table test.t2 (t int);create temporary table test.t3 (t int);create temporary table test.t4 (t int);create temporary table test.t5 (t int);
Query OK, 0 rows affected (0.09 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.02 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)


mysql-slave&amp;gt; show status like &#39;%open%&#39;;
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
...
| Innodb_num_open_files      | 11    |
| Open_files                 | 22    |
| Open_streams               | 0     |
| Open_table_definitions     | 70    |
| Open_tables                | 63    |
| Opened_files               | 224   |
| Opened_table_definitions   | 0     |
| Opened_tables              | 0     |
| Slave_open_temp_tables     | 10    |
...
+----------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;: 复制临时表时,slave上消耗的资源, &lt;code&gt;Innodb_num_open_files&lt;/code&gt;会及时回收,也就是说实际消耗的系统资源被及时回收. 但&lt;code&gt;Slave_open_temp_tables&lt;/code&gt;会虚高不下,按照Mysql Manual中&amp;rdquo;Safe slave shutdown when using temporary tables&amp;rdquo;的叙述, 用&lt;code&gt;Slave_open_temp_tables&lt;/code&gt;来判断关闭server的时机时, 会出现判断失误.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>对Mysql bug #70307 的再学习</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-01-study-mysql-bug-70307-2</link>
      <pubDate>Tue, 01 Apr 2014 13:07:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-04-01-study-mysql-bug-70307-2</guid>
      <description>

&lt;p&gt;之前对bug #70307有过&lt;a href=&#34;http://ikarishinjieva.github.io/blog/blog/2013/10/25/study-mysql-bug-70307/&#34;&gt;学习&lt;/a&gt;, 苦于阿兹海默状态, 又花了半天在mysql 5.5.33上探查这个场景的原因&amp;hellip;&lt;/p&gt;

&lt;p&gt;简单记录一下&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;mysql进行主从复制, 从机上&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;后, 进行&lt;code&gt;STOP SLAVE&lt;/code&gt;, 一定概率下 &lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;卡住&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;重现步骤&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;master&lt;/th&gt;
&lt;th&gt;slave client 1&lt;/th&gt;
&lt;th&gt;slave client 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;STOP SLAVE IO_THREAD&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CREATE TABLE TEST.TEST &amp;hellip;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;FLUSH TABLES WITH READ LOCK&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;START SLAVE IO_THREAD&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;STOP SLAVE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;SHOW SLAVE STATUS&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中, &lt;code&gt;START/STOP SLAVE IO_THREAD&lt;/code&gt;是为了在&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;时造成slave io_thread有未提交数据&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;死锁原因&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; 会阻塞IO_THREAD提交数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STOP SLAVE&lt;/code&gt;会等待IO_THREAD结束 (&lt;code&gt;mi-&amp;gt;stop_cond&lt;/code&gt;), 即&lt;code&gt;STOP SLAVE&lt;/code&gt;间接被&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STOP SLAVE&lt;/code&gt;在被阻塞前, 持有了&lt;code&gt;LOCK_active_mi&lt;/code&gt;, 独占了&lt;code&gt;master_info&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;会申请锁&lt;code&gt;LOCK_active_mi&lt;/code&gt;, 被&lt;code&gt;STOP SLAVE&lt;/code&gt;阻塞&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt;是由之前&lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;的&lt;code&gt;slave client 1&lt;/code&gt;发出的, 那逻辑上相当于自己在等待自己释放资源&lt;/li&gt;
&lt;li&gt;从另外的client上&lt;code&gt;UNLOCK TABLES&lt;/code&gt;也解不开&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>mysql, 利用假master重放binlog</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-03-26-mysql-fake-master-server</link>
      <pubDate>Wed, 26 Mar 2014 20:08:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-03-26-mysql-fake-master-server</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;这次想解决的场景是想在一个mysqld实例上重放一些来自于其他实例的binlog, 传统的方法是&lt;code&gt;mysqlbinlog&lt;/code&gt;. 但是&lt;code&gt;mysqlbinlog&lt;/code&gt;会带来一些问题, 比如这个&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=33048&#34;&gt;bug&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后同事转给我一种利用&lt;a href=&#34;http://www.orczhou.com/index.php/2013/11/use-mysql-replication-to-recove-binlog/&#34;&gt;复制重放binlog的方法&lt;/a&gt;, 其中提到两种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种是修改relay log的信息, 将binlog作为relay log来放. 这是种很好的方法, 缺点是&lt;code&gt;mysqld&lt;/code&gt;需要停机重启. 如果不重启, server中对于&lt;code&gt;relay-log.index&lt;/code&gt;和&lt;code&gt;relay-log.info&lt;/code&gt;等的缓存不会刷新.&lt;/li&gt;
&lt;li&gt;第二种是起另外一个mysqld实例, 将binlog作为relay log, 再将此实例作为master, 向目标实例进行复制. 这种方式的缺点是作为中间人的mysqld实例需要消耗资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是想办法将第二种方法进行改进, 即制造一个假的master, 实现简单的复制协议, 直接将binlog复制给目标mysqld实例. 与第二种方式相比, 好处在于只使用少量资源 (一个端口, 一点用来读文件的内存).&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;实现&lt;/h2&gt;

&lt;p&gt;实现参看我的&lt;a href=&#34;https://github.com/ikarishinjieva/mysql_binlog_utils/blob/master/fake_master_server.go&#34;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意: 此实现仅适用于mysql 5.5.33, 其它版本未测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/client-server-protocol.html&#34;&gt;mysql internals&lt;/a&gt; 已经将mysql的网络协议写的比较详细, 需要做的只是起一个tcp的server, 同目标mysqld实例进行交互即可.&lt;/p&gt;

&lt;p&gt;此处逐层介绍实现, 将忽略不需要特别注意的部分. 为了简单, 将binlog的来源mysqld实例称为A, 目标mysqld实例称为B, 假master称为T.&lt;/p&gt;

&lt;p&gt;目标就是讲从A获得的binlog文件, 通过T, 在B上重放出来&lt;/p&gt;

&lt;p&gt;从B发起&lt;code&gt;start slave&lt;/code&gt;, 到T真正向B复制数据, 需要下面两个阶段&lt;/p&gt;

&lt;p&gt;.1. Handshake Phase&lt;/p&gt;

&lt;p&gt;.2. Replication Phase&lt;/p&gt;

&lt;p&gt;先介绍Handshake Phase, 有以下步骤&lt;/p&gt;

&lt;p&gt;.1.1 B执行&lt;code&gt;start slave&lt;/code&gt;, 此时B向T建立一个TCP连接&lt;/p&gt;

&lt;p&gt;.1.2 T向B发送handshake packet&lt;/p&gt;

&lt;p&gt;.1.3 B向T回复handshake packet response&lt;/p&gt;

&lt;p&gt;.1.4 T向B发送ok packet&lt;/p&gt;

&lt;p&gt;在Replication Phase, 有以下步骤&lt;/p&gt;

&lt;p&gt;.2.1 B向T查询&lt;code&gt;SELECT UNIX_TIMESTAMP()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.2.2 B向T查询&lt;code&gt;SHOW VARIABLES LIKE &#39;SERVER_ID&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.2.3 B向T执行&lt;code&gt;SET @master_heartbeat_period=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;.2.4 B向T发送COM_REGISTER_SLAVE packet, 得到T回复的ok packet&lt;/p&gt;

&lt;p&gt;.2.5 B向T发送COM_BINLOG_DUMP packet, T开始向B逐一发送binlog event packet&lt;/p&gt;

&lt;p&gt;到目前为止, 所有的packet定义都可以在&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/client-server-protocol.html&#34;&gt;mysql internals&lt;/a&gt;, 逐一实现即可. 这里只简述一些处理packet时需要注意的细节.&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;处理packet时需要注意的细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;所有的packet都会包装一个&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/mysql-packet.html&#34;&gt;header&lt;/a&gt;, 其中包括packet payload(不包括header)的大小, 和序号&lt;/li&gt;
&lt;li&gt;对于序号的处理, 比如2.2中B向T查询&lt;code&gt;SHOW VARIABLES LIKE &#39;SERVER_ID&#39;&lt;/code&gt;, B向T发送的第一个包序号为0, T向B回复的几个包序号依次递增为1,2,3&amp;hellip;&lt;/li&gt;
&lt;li&gt;注意数据类型, 仅整数, mysql的协议里有&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/integer.html&#34;&gt;定长整数&lt;/a&gt;和变长整数(length encoded integer), 需要特别留意packet payload的类型描述&lt;/li&gt;
&lt;li&gt;说明一下&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-COM_QUERY_Response&#34;&gt;query response packet&lt;/a&gt;. 比如B向T做一个查询, T将通过query response packet来返回查询结果. 需要说明的是, 如果查询结果为空 (比如&lt;code&gt;SET @master_heartbeat_period= ?&lt;/code&gt;的结果), 仅需返回&lt;code&gt;COM_QUERY_RESPONSE&lt;/code&gt;, 后面不需要跟着空的column定义和row数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;对超大packet的支持&lt;/h2&gt;

&lt;p&gt;当一个packet过大 (超过&lt;code&gt;1&amp;lt;&amp;lt;24-1&lt;/code&gt;byte ~= 16 MB) 时, 传输需要对packet进行切割, 参看&lt;a href=&#34;http://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意, 在A上生成binlog时, 是可以容纳大于16MB的packet的, 也就是原binlog里存在超大的event, 需要在传输时加以限制&lt;/p&gt;

&lt;p&gt;切割packet没什么特别之处, 仅需要注意包格式, 一个20MB的event的传输packet格式举例为 (此处用&lt;code&gt;16MB&lt;/code&gt;便于描述, 应为&lt;code&gt;1&amp;lt;&amp;lt;24-1&lt;/code&gt;byte):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    packet 1
        4字节 packet header
        1字节 值为[00], 是binlog event的特征标志
        16MB-1字节 为第一段数据
        
    packet 2
        4字节 packet header
        20MB-16MB+1字节 为第二段数据
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是之后的packet时不带有[00]特征位的. 而包的大小计算范围为&lt;strong&gt;除去前4字节&lt;/strong&gt;的全部字节&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;一些资料&lt;/h2&gt;

&lt;p&gt;除上文提到的资料, 还推荐&lt;a href=&#34;http://boytnt.blog.51cto.com/966121/1279318&#34;&gt;MySQL通讯协议研究系列&lt;/a&gt;, 会对包格式有个直观感觉&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Trouble shooting&lt;/h2&gt;

&lt;p&gt;在整个过程中, 有时候需要&lt;code&gt;gdb&lt;/code&gt;到&lt;code&gt;mysqld&lt;/code&gt;里来了解通讯协议的工作机制, 这里记录几个常用的函数入口点&lt;/p&gt;

&lt;p&gt;.1. slave连接到master时&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  wait_for_data (fd=21, timeout=3600) at /vagrant/mysql-5.5.35/sql-common/client.c:208
    #1  0x00000000007316aa in my_connect (fd=21, name=0x7fa074004fd0, namelen=16, timeout=3600) at /vagrant/mysql-5.5.35/sql-common/client.c:187
    #2  0x00000000007363cb in mysql_real_connect (mysql=0x7fa074004960, host=0x3959cc8 &amp;quot;192.168.56.1&amp;quot;, user=0x3959d05 &amp;quot;repl&amp;quot;, passwd=0x3959d36 &amp;quot;&amp;quot;, db=0x0, port=3306, unix_socket=0x0, client_flag=2147483648)
        at /vagrant/mysql-5.5.35/sql-common/client.c:3282
    #3  0x000000000057f138 in connect_to_master (thd=0x7fa074000a40, mysql=0x7fa074004960, mi=0x3959640, reconnect=false, suppress_warnings=false) at /vagrant/mysql-5.5.35/sql/slave.cc:4297
    #4  0x000000000057edd1 in safe_connect (thd=0x7fa074000a40, mysql=0x7fa074004960, mi=0x3959640) at /vagrant/mysql-5.5.35/sql/slave.cc:4233
    #5  0x000000000057b15c in handle_slave_io (arg=0x3959640) at /vagrant/mysql-5.5.35/sql/slave.cc:2851
    #6  0x00007fa096751851 in start_thread () from /lib64/libpthread.so.0
    #7  0x00007fa0954a690d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.2. handshake phase&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  send_server_handshake_packet (mpvio=0x7fa0942eb450, data=0x391e5b4 &amp;quot;=!-\\gq$\\%&amp;gt;J8z}&#39;EgVW5&amp;quot;, data_len=21) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:8084
    #1  0x000000000059a87c in server_mpvio_write_packet (param=0x7fa0942eb450, packet=0x391e5b4 &amp;quot;=!-\\gq$\\%&amp;gt;J8z}&#39;EgVW5&amp;quot;, packet_len=21) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9082
    #2  0x000000000059bc99 in native_password_authenticate (vio=0x7fa0942eb450, info=0x7fa0942eb468) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9713
    #3  0x000000000059ad86 in do_auth_once (thd=0x391cc70, auth_plugin_name=0x1026760, mpvio=0x7fa0942eb450) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9336
    #4  0x000000000059b23a in acl_authenticate (thd=0x391cc70, connect_errors=0, com_change_user_pkt_len=0) at /vagrant/mysql-5.5.35/sql/sql_acl.cc:9472
    #5  0x00000000006d9eb5 in check_connection (thd=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:575
    #6  0x00000000006d9ffc in login_connection (thd=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:633
    #7  0x00000000006da5ba in thd_prepare_connection (thd=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:789
    #8  0x00000000006daa28 in do_handle_one_connection (thd_arg=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:855
    #9  0x00000000006da583 in handle_one_connection (arg=0x391cc70) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:781
    #10 0x00007fa096751851 in start_thread () from /lib64/libpthread.so.0
    #11 0x00007fa0954a690d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.3. query时回复column定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  Protocol::send_result_set_metadata (this=0x3767610, list=0x3769328, flags=5)
        at /vagrant/mysql-5.5.35/sql/protocol.cc:677
    #1  0x00000000005c6745 in select_send::send_result_set_metadata (this=0x7f350c001658, list=..., flags=5)
        at /vagrant/mysql-5.5.35/sql/sql_class.cc:2132
    #2  0x000000000062895a in JOIN::exec (this=0x7f350c001678) at /vagrant/mysql-5.5.35/sql/sql_select.cc:1858
    #3  0x000000000062b2a0 in mysql_select (thd=0x37670e0, rref_pointer_array=0x3769400, tables=0x0, wild_num=0,
        fields=..., conds=0x0, og_num=0, order=0x0, group=0x0, having=0x0, proc_param=0x0, select_options=2147748608,
        result=0x7f350c001658, unit=0x3768bf8, select_lex=0x3769218) at /vagrant/mysql-5.5.35/sql/sql_select.cc:2604
    #4  0x00000000006232f5 in handle_select (thd=0x37670e0, lex=0x3768b48, result=0x7f350c001658,
        setup_tables_done_option=0) at /vagrant/mysql-5.5.35/sql/sql_select.cc:297
    #5  0x00000000005fe82d in execute_sqlcom_select (thd=0x37670e0, all_tables=0x0)
        at /vagrant/mysql-5.5.35/sql/sql_parse.cc:4627
    #6  0x00000000005f7379 in mysql_execute_command (thd=0x37670e0) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:2178
    #7  0x0000000000600a43 in mysql_parse (thd=0x37670e0, rawbuf=0x7f350c001430 &amp;quot;SELECT UNIX_TIMESTAMP()&amp;quot;, length=23,
        parser_state=0x7f35195056f0) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:5664
    #8  0x00000000005f490a in dispatch_command (command=COM_QUERY, thd=0x37670e0,
        packet=0x3770e21 &amp;quot;SELECT UNIX_TIMESTAMP()&amp;quot;, packet_length=23) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:1040
    #9  0x00000000005f3c00 in do_command (thd=0x37670e0) at /vagrant/mysql-5.5.35/sql/sql_parse.cc:773
    #10 0x00000000006daa4b in do_handle_one_connection (thd_arg=0x37670e0)
        at /vagrant/mysql-5.5.35/sql/sql_connect.cc:862
    #11 0x00000000006da583 in handle_one_connection (arg=0x37670e0) at /vagrant/mysql-5.5.35/sql/sql_connect.cc:781
    #12 0x00007f352e043851 in start_thread () from /lib64/libpthread.so.0
    #13 0x00007f352cd9890d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.4. query读取数据结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  cli_read_query_result (mysql=0x7f3508004960) at /vagrant/mysql-5.5.35/sql-common/client.c:3829
    #1  0x0000000000738016 in mysql_real_query (mysql=0x7f3508004960, query=0xb80e34 &amp;quot;SELECT UNIX_TIMESTAMP()&amp;quot;,
        length=23) at /vagrant/mysql-5.5.35/sql-common/client.c:3918
    #2  0x00000000005766ec in get_master_version_and_clock (mysql=0x7f3508004960, mi=0x375b400)
        at /vagrant/mysql-5.5.35/sql/slave.cc:1328
    #3  0x000000000057b35a in handle_slave_io (arg=0x375b400) at /vagrant/mysql-5.5.35/sql/slave.cc:2881
    #4  0x00007f352e043851 in start_thread () from /lib64/libpthread.so.0
    #5  0x00007f352cd9890d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.5. slave发送COM_BINLOG_DUMP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #0  request_dump (thd=0x7f35f80008c0, mysql=0x7f35f80076c0, mi=0x3301ac0,
        suppress_warnings=0x7f361c189e2b)
        at /vagrant/mysql-5.5.35/sql/slave.cc:2184
    #1  0x000000000057b596 in handle_slave_io (arg=0x3301ac0)
        at /vagrant/mysql-5.5.35/sql/slave.cc:2935
    #2  0x00007f3620c66851 in start_thread () from /lib64/libpthread.so.0
    #3  0x00007f361f9bb90d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>尝试使用mysql plugin将RESET SLAVE后的节点重新恢复成slave</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-02-11-try-rollback-master-back-to-slave-by-mysql-plugin</link>
      <pubDate>Tue, 11 Feb 2014 22:31:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2014-02-11-try-rollback-master-back-to-slave-by-mysql-plugin</guid>
      <description>

&lt;p&gt;这几天在尝试为以下场景制作一个mysql plugin, 但是是一个失败的尝试, 在此记录&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;场景&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;一对mysql主从节点 M-S, 节点S执行了RESET SLAVE
后来后悔了
在没有数据通过非replication的渠道写入S的条件下, 想让S和M重新恢复成一对主从
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键点是S能将&lt;code&gt;RESET SLAVE&lt;/code&gt;时S的&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;和&lt;code&gt;S binlog pos&lt;/code&gt;记录下来&lt;/p&gt;

&lt;p&gt;尝试了以下几种方案:&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;调用者在&lt;code&gt;RESET SLAVE&lt;/code&gt;时手工记录, 不需要制作插件&lt;/h2&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Audit plugin.&lt;/h2&gt;

&lt;p&gt;Mysql的Audit plugin可以审计大部分mysqld经手的SQL, 包括&lt;code&gt;RESET SLAVE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;但Audit plugin是在每个SQL之后才会调用. 在&lt;code&gt;RESET SLAVE&lt;/code&gt;时S上master_info会被清理, 即&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;的信息在调用Audit plugin已经丢失&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Replication plugin (&lt;code&gt;after_reset_slave&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;Replication plugin (参看mysql semisync的源码), 在slave端提供了&lt;code&gt;Binlog_relay_IO_observer&lt;/code&gt;, 贴个Mysql源码方便理解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
    Observes and extends the service of slave IO thread.
 */
 typedef struct Binlog_relay_IO_observer {
   uint32 len;

   /**
      This callback is called when slave IO thread starts

      @param param Observer common parameter

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*thread_start)(Binlog_relay_IO_param *param);

   /**
      This callback is called when slave IO thread stops

      @param param Observer common parameter

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*thread_stop)(Binlog_relay_IO_param *param);

   /**
      This callback is called before slave requesting binlog transmission from master

      This is called before slave issuing BINLOG_DUMP command to master
      to request binlog.

      @param param Observer common parameter
      @param flags binlog dump flags

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*before_request_transmit)(Binlog_relay_IO_param *param, uint32 flags);

   /**
      This callback is called after read an event packet from master

      @param param Observer common parameter
      @param packet The event packet read from master
      @param len Length of the event packet read from master
      @param event_buf The event packet return after process
      @param event_len The length of event packet return after process

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*after_read_event)(Binlog_relay_IO_param *param,
                           const char *packet, unsigned long len,
                           const char **event_buf, unsigned long *event_len);

   /**
      This callback is called after written an event packet to relay log

      @param param Observer common parameter
      @param event_buf Event packet written to relay log
      @param event_len Length of the event packet written to relay log
      @param flags flags for relay log

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*after_queue_event)(Binlog_relay_IO_param *param,
                            const char *event_buf, unsigned long event_len,
                            uint32 flags);

   /**
      This callback is called after reset slave relay log IO status

      @param param Observer common parameter

      @retval 0 Sucess
      @retval 1 Failure
   */
   int (*after_reset_slave)(Binlog_relay_IO_param *param);
 } Binlog_relay_IO_observer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先尝试用&lt;code&gt;after_reset_slave&lt;/code&gt;, 从函数名字就可以看到会遇到和Audit Plugin相同的问题: 即&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;的信息在调用时已经丢失&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Replication plugin (&lt;code&gt;after_reset_slave&lt;/code&gt;再尝试, &lt;code&gt;future_group_master_log_pos&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;还不死心, &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;的数据结构是&lt;code&gt;Relay_log_info.group_master_log_pos&lt;/code&gt;, 尽管这个信息在&lt;code&gt;after_reset_slave&lt;/code&gt;时已经丢失, 但发现&lt;code&gt;Relay_log_info.future_group_master_log_pos&lt;/code&gt;可能是个方向&lt;/p&gt;

&lt;p&gt;先解释&lt;code&gt;Relay_log_info.future_group_master_log_pos&lt;/code&gt;, 可以参看&lt;code&gt;log_event.cc&lt;/code&gt;的这段注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /*
    InnoDB internally stores the master log position it has executed so far,
    i.e. the position just after the COMMIT event.
    When InnoDB will want to store, the positions in rli won&#39;t have
    been updated yet, so group_master_log_* will point to old BEGIN
    and event_master_log* will point to the beginning of current COMMIT.
    But log_pos of the COMMIT Query event is what we want, i.e. the pos of the
    END of the current log event (COMMIT). We save it in rli so that InnoDB can
    access it.
  */
  const_cast&amp;lt;Relay_log_info*&amp;gt;(rli)-&amp;gt;future_group_master_log_pos= log_pos;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;future_group_master_log_pos&lt;/code&gt;指向了execute的最后一个transaction的COMMIT event之前, 即&lt;code&gt;future_group_master_log_pos&lt;/code&gt; 大部分时间等于 &lt;code&gt;group_master_log_pos - 27&lt;/code&gt; (27是COMMIT event的长度)&lt;/p&gt;

&lt;p&gt;但仍有例外情况: 如果M执行了&lt;code&gt;FLUSH LOGS&lt;/code&gt;, 将log从0001递增到了0002, 此时S上的&lt;code&gt;future_group_master_log_pos&lt;/code&gt;会指向0001的最后一个transaction的COMMIT event之前. 但S上的&lt;code&gt;group_master_log_name&lt;/code&gt;已经到了0002, 与&lt;code&gt;future_group_master_log_pos&lt;/code&gt;不匹配, 会引起异常&lt;/p&gt;

&lt;p&gt;(其实此时S上的&lt;code&gt;group_master_log_name&lt;/code&gt;也已经置空了, 但可以从内存残片中恢复出文件名)&lt;/p&gt;

&lt;p&gt;设想如果对于log_name也有&lt;code&gt;future_group_master_log_name&lt;/code&gt;, 那么S可以直接&lt;code&gt;change master&lt;/code&gt;到M的&lt;code&gt;future_group_master_log_name&lt;/code&gt;和&lt;code&gt;future_group_master_log_pos&lt;/code&gt;位置, 可以恢复起M-S主从结构&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Replication plugin (&lt;code&gt;thread_stop&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;Replication plugin的&lt;code&gt;thread_stop&lt;/code&gt;是指Slave IO thread停止时调用, 此时可以拿到&lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;和&lt;code&gt;S binlog pos&lt;/code&gt;, 但拿到的&lt;code&gt;S binlog pos&lt;/code&gt;没有意义, 因为不能保证Slave SQL thread也停下来了&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Storage Engine plugin&lt;/h2&gt;

&lt;p&gt;这是我最后一根救命稻草, 阅读Mysql源码时注意到以下片段(做了缩减)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int reset_slave(THD *thd, Master_info* mi)
{
    ...
    ha_reset_slave(thd);
    ... //clean memory data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;reset_slave&lt;/code&gt;在清理内存数据前通知了storage engine插件, 这个插件可以获得所有必要信息&lt;/p&gt;

&lt;p&gt;但存在一个问题, 即&lt;code&gt;ha_reset_slave&lt;/code&gt;仅在Mysql NDB版本中存在, 不具备通用性, 参看宏定义(做了缩减)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef HAVE_NDB_BINLOG
...
void ha_reset_slave(THD *thd);
...
#else
...
#define ha_reset_slave(a) do {} while (0)
...
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;吐槽和总结&lt;/h2&gt;

&lt;p&gt;可以看到Mysql plugin不&lt;strong&gt;太&lt;/strong&gt;预留接口, 是仅仅为已知应用场景提供必要接口, 比如&lt;code&gt;Binlog_relay_IO_observer&lt;/code&gt;中有&lt;code&gt;after&lt;/code&gt;不一定有&lt;code&gt;before&lt;/code&gt;. 比较容易控制插件质量, 但插件能做到的非常局限.&lt;/p&gt;

&lt;p&gt;以上各种尝试, 归根到底, 只要修改Mysql的一点源码编译一下就可以达到很好的效果, 不需要用插件的方式在Mysql中到处找功能插槽, 但通用性变差.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>对Mysql bug #70307 的学习</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-25-study-mysql-bug-70307</link>
      <pubDate>Fri, 25 Oct 2013 22:00:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-25-study-mysql-bug-70307</guid>
      <description>

&lt;p&gt;之前描述&lt;a href=&#34;http://ikarishinjieva.github.io/blog/blog/2013/10/11/hole-in-mysql-56-replication-dead-lock/&#34;&gt;Mysql 5.6.15 Replication中碰到的死锁&lt;/a&gt;的情况，这次尝试debug下原因。&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;debug的过程&lt;/h2&gt;

&lt;p&gt;用参数&amp;ndash;gdb启动mysql，按照&lt;a href=&#34;http://bugs.mysql.com/file.php?id=20542&#34;&gt;步骤&lt;/a&gt;重现bug（让slave &amp;ldquo;show slave status&amp;rdquo;时卡住）。然后用gdb attach到slave mysql实例上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) thread apply all bt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出所有线程的backtrace，找到show slave status卡住的线程和位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Thread 2 (Thread 0x7f583c166700 (LWP 2440)):
#0  0x00007f583f484054 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x00007f583f47f3be in _L_lock_995 () from /lib64/libpthread.so.0
#2  0x00007f583f47f326 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x0000000000aa3cde in safe_mutex_lock (mp=0x3516ae8, try_lock=0 &#39;\000&#39;, file=0xfb8e58 &amp;quot;/home/vagrant/mysql-5.6.12/sql/rpl_slave.cc&amp;quot;, line=2611) at /home/vagrant/mysql-5.6.12/mysys/thr_mutex.c:152
#4  0x0000000000a4b993 in inline_mysql_mutex_lock (that=0x3516ae8, src_file=0xfb8e58 &amp;quot;/home/vagrant/mysql-5.6.12/sql/rpl_slave.cc&amp;quot;, src_line=2611) at /home/vagrant/mysql-5.6.12/include/mysql/psi/mysql_thread.h:686
#5  0x0000000000a53cb3 in show_slave_status (thd=0x352e3d0, mi=0x34b4f20) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:2611
#6  0x00000000007d45f4 in mysql_execute_command (thd=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:2766
#7  0x00000000007ddc46 in mysql_parse (thd=0x352e3d0, rawbuf=0x7f57ec005010 &amp;quot;show slave status&amp;quot;, length=17, parser_state=0x7f583c165660) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:6187
#8  0x00000000007d1019 in dispatch_command (command=COM_QUERY, thd=0x352e3d0, packet=0x3534e51 &amp;quot;&amp;quot;, packet_length=17) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1334
#9  0x00000000007d017b in do_command (thd=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1036
#10 0x0000000000797a08 in do_handle_one_connection (thd_arg=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:977
#11 0x00000000007974e4 in handle_one_connection (arg=0x352e3d0) at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:893
#12 0x0000000000aea87a in pfs_spawn_thread (arg=0x351b510) at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#13 0x00007f583f47d851 in start_thread () from /lib64/libpthread.so.0
#14 0x00007f583e3e890d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到show slave status卡在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#5  0x0000000000a53cb3 in show_slave_status (thd=0x352e3d0, mi=0x34b4f20) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:2611
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找源码可以看到show slave status卡在获取锁mi-&amp;gt;rli-&amp;gt;data_lock上&lt;br/&gt;(科普下缩写: mi=master info, rli=relay log info&lt;/p&gt;

&lt;p&gt;在gdb中运行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) thread 2
(gdb) f 5
(gdb) print mi-&amp;gt;rli-&amp;gt;data_lock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换到thread 2堆栈第5层的上下文，打印出mi-&amp;gt;rli-&amp;gt;data_lock变量，输出如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$1 = {m_mutex = {global = {__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 2, __spins = 0,
    __list = {__prev = 0x0, __next = 0x0}},
  __size = &#39;\000&#39; &amp;lt;repeats 16 times&amp;gt;, &amp;quot;\002&amp;quot;, &#39;\000&#39; &amp;lt;repeats 22 times&amp;gt;, __align = 0}, mutex = {__data = {
    __lock = 2, __count = 0, __owner = 2435, __nusers = 1, __kind = 3, __spins = 0, __list = {__prev = 0x0,
      __next = 0x0}},
  __size = &amp;quot;\002\000\000\000\000\000\000\000\203\t\000\000\001\000\000\000\003&amp;quot;, &#39;\000&#39; &amp;lt;repeats 22 times&amp;gt;,
  __align = 2}, file = 0xfa4520 &amp;quot;/home/vagrant/mysql-5.6.12/sql/log_event.cc&amp;quot;, line = 7259, count = 1,
thread = 140016942216960}, m_psi = 0x0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到锁的owner是线程(LWP 2435)，为Thread 3&lt;/p&gt;

&lt;p&gt;Thread 3的backtrace如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Thread 3 (Thread 0x7f583c1a7700 (LWP 2435)):
#0  0x00007f583f4817bb in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x0000000000aa429d in safe_cond_timedwait (cond=0x7f57f4000ba8, mp=0x7f57f4000b38, abstime=0x7f583c1a60f0, file=0xedc960 &amp;quot;/home/vagrant/mysql-5.6.12/include/mysql/psi/mysql_thread.h&amp;quot;, line=1199) at /home/vagrant/mysql-5.6.12/mysys/thr_mutex.c:278
#2  0x00000000007121f4 in inline_mysql_cond_timedwait (that=0x7f57f4000ba8, mutex=0x7f57f4000b38, abstime=0x7f583c1a60f0, src_file=0xedcb98 &amp;quot;/home/vagrant/mysql-5.6.12/sql/mdl.cc&amp;quot;, src_line=1306) at /home/vagrant/mysql-5.6.12/include/mysql/psi/mysql_thread.h:1199
#3  0x0000000000713111 in MDL_wait::timed_wait (this=0x7f57f4000b38, owner=0x7f57f4000a50, abs_timeout=0x7f583c1a60f0, set_status_on_timeout=true, wait_state_name=0x14d0488) at /home/vagrant/mysql-5.6.12/sql/mdl.cc:1306
#4  0x0000000000714811 in MDL_context::acquire_lock (this=0x7f57f4000b38, mdl_request=0x7f583c1a6180, lock_wait_timeout=31536000) at /home/vagrant/mysql-5.6.12/sql/mdl.cc:2241
#5  0x000000000063656a in ha_commit_trans (thd=0x7f57f4000a50, all=true) at /home/vagrant/mysql-5.6.12/sql/handler.cc:1396 (COMMIT LOCK)
#6  0x00000000008a010b in trans_commit (thd=0x7f57f4000a50) at /home/vagrant/mysql-5.6.12/sql/transaction.cc:228
#7  0x0000000000a081bb in Xid_log_event::do_commit (this=0x7f57f4004730, thd=0x7f57f4000a50) at /home/vagrant/mysql-5.6.12/sql/log_event.cc:7174
#8  0x0000000000a0886e in Xid_log_event::do_apply_event (this=0x7f57f4004730, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/log_event.cc:7310 (rli-&amp;gt;data_lock)
#9  0x00000000009fd956 in Log_event::apply_event (this=0x7f57f4004730, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/log_event.cc:3049
#10 0x0000000000a55e31 in apply_event_and_update_pos (ptr_ev=0x7f583c1a68a0, thd=0x7f57f4000a50, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:3374
#11 0x0000000000a56e45 in exec_relay_log_event (thd=0x7f57f4000a50, rli=0x3516650) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:3742
#12 0x0000000000a5c334 in handle_slave_sql (arg=0x34b4f20) at /home/vagrant/mysql-5.6.12/sql/rpl_slave.cc:5552
#13 0x0000000000aea87a in pfs_spawn_thread (arg=0x350a800) at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#14 0x00007f583f47d851 in start_thread () from /lib64/libpthread.so.0
#15 0x00007f583e3e890d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Thread 3卡在commit lock上，同时查源码看到Thread 3同时占有了rli-&amp;gt;data_lock (log_event.cc:7259)&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;锁的状态&lt;/h2&gt;

&lt;p&gt;按照bug的描述，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flush tables with read lock; 会持有commit lock&lt;/li&gt;
&lt;li&gt;IO thread (Thread 3)会持有rli-&amp;gt;data_lock，并等待commit lock&lt;/li&gt;
&lt;li&gt;show slave status; 会等待rli-&amp;gt;data_lock&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结果导致show slave status卡住不可用&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;臆测一下解决方法&lt;/h2&gt;

&lt;p&gt;鉴于功底不深，只能臆测一下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;IO thread持有锁rli-&amp;gt;data_lock的原因是要更新relay log的状态，然后进行commit(Xid_log_event::do_apply_event (log_event.cc:7248))。在commit的时候不会更新rli的数据。&lt;/li&gt;
&lt;li&gt;show slave status不会更新rli的数据，需要锁rli-&amp;gt;data_lock的原因是要一致性数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此可能的解决方案是IO thread持有读写锁，进行commit时转为持有读锁。show slave status只使用读锁。&lt;/p&gt;

&lt;p&gt;只是臆测下解决方法，待&lt;a href=&#34;http://bugs.mysql.com/bug.php?id=70307&#34;&gt;bug #70307&lt;/a&gt;修掉时再学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql 5.6.12 master上flush logs在slave上产生两个relay-log</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-22-mysql-flush-logs-make-two-relay-log-file</link>
      <pubDate>Tue, 22 Oct 2013 21:42:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-22-mysql-flush-logs-make-two-relay-log-file</guid>
      <description>

&lt;h2 id=&#34;toc_0&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;一个碰巧观察到的有趣的现象：mysql 5.6.12 在master上flush logs，在slave上会观察到两个新的relay-log file&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;p&gt;slave-relay-bin.000092&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; FD event
 Rotate to mysql-bin.000056
 Rotate to slave-relay-bin.000093
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;slave-relay-bin.000093&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; FD event slave
 Rotate to mysql-bin.000056
 FD event master
 bla bla…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到000092这个relay log相当多余。这个现象并不会影响replication的正确性，只是让有强迫症的人有点狂躁&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;探索&lt;/h2&gt;

&lt;p&gt;在master上net_serv.cc:my_net_write打断点，可以观察到master的确发出了以下三个事件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ROTATE_EVENT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;backtrace&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#0  my_net_write (net=0x1ea2858, packet=0x7fffa4002b70 &amp;quot;&amp;quot;, len=48)
    at /home/vagrant/mysql-5.6.12/sql/net_serv.cc:284
#1  0x0000000000a48b05 in mysql_binlog_send (thd=0x1ea2600, log_ident=0x7fffa4004c60 &amp;quot;mysql-bin.000052&amp;quot;, pos=167,
    slave_gtid_executed=0x0) at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:1336
#2  0x0000000000a46ad2 in com_binlog_dump (thd=0x1ea2600, packet=0x1ea5d21 &amp;quot;&amp;quot;, packet_length=26)
    at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:746
#3  0x00000000007d1ab9 in dispatch_command (command=COM_BINLOG_DUMP, thd=0x1ea2600, packet=0x1ea5d21 &amp;quot;&amp;quot;,
    packet_length=26) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1534
#4  0x00000000007d017b in do_command (thd=0x1ea2600) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1036
#5  0x0000000000797a08 in do_handle_one_connection (thd_arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:977
#6  0x00000000007974e4 in handle_one_connection (arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:893
#7  0x0000000000aea87a in pfs_spawn_thread (arg=0x1e7aa80)
    at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#8  0x00007ffff7bc7851 in start_thread () from /lib64/libpthread.so.0
#9  0x00007ffff6b3290d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第二个ROTATE_EVENT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;backtrace&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#0  my_net_write (net=0x1ea2858, packet=0x7fffa4002ab0 &amp;quot;&amp;quot;, len=48)
    at /home/vagrant/mysql-5.6.12/sql/net_serv.cc:284
#1  0x0000000000a45f04 in fake_rotate_event (net=0x1ea2858, packet=0x1ea2be8,
    log_file_name=0x7fffc94ff270 &amp;quot;./mysql-bin.000056&amp;quot;, position=4, errmsg=0x7fffc94ffdb0,
    checksum_alg_arg=1 &#39;\001&#39;) at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:395
#2  0x0000000000a4a33d in mysql_binlog_send (thd=0x1ea2600, log_ident=0x7fffa4004c60 &amp;quot;mysql-bin.000052&amp;quot;, pos=167,
    slave_gtid_executed=0x0) at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:1728
#3  0x0000000000a46ad2 in com_binlog_dump (thd=0x1ea2600, packet=0x1ea5d21 &amp;quot;&amp;quot;, packet_length=26)
    at /home/vagrant/mysql-5.6.12/sql/rpl_master.cc:746
#4  0x00000000007d1ab9 in dispatch_command (command=COM_BINLOG_DUMP, thd=0x1ea2600, packet=0x1ea5d21 &amp;quot;&amp;quot;,
    packet_length=26) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1534
#5  0x00000000007d017b in do_command (thd=0x1ea2600) at /home/vagrant/mysql-5.6.12/sql/sql_parse.cc:1036
#6  0x0000000000797a08 in do_handle_one_connection (thd_arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:977
#7  0x00000000007974e4 in handle_one_connection (arg=0x1ea2600)
    at /home/vagrant/mysql-5.6.12/sql/sql_connect.cc:893
#8  0x0000000000aea87a in pfs_spawn_thread (arg=0x1e7aa80)
    at /home/vagrant/mysql-5.6.12/storage/perfschema/pfs.cc:1855
#9  0x00007ffff7bc7851 in start_thread () from /lib64/libpthread.so.0
#10 0x00007ffff6b3290d in clone () from /lib64/libc.so.6
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;FORMAT_DESCRIPTION_EVENT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到第一个ROTATE_EVENT是由flush logs发出的，第二个ROTATE_EVENT是fake_rotate_event&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;关于fake_rotate_event&lt;/h2&gt;

&lt;p&gt;以前也&lt;a href=&#34;http://ikarishinjieva.github.io/blog/blog/2013/10/16/mysql-mysql_binlog_send-src/&#34;&gt;吐槽&lt;/a&gt;过fake_rotate_event&lt;/p&gt;

&lt;p&gt;master在binlog切换时（不一定是手工flush，也可能是重启，或者容量达到限制）一定要多发一个rotate event，原因如源码rpl_master.cc:mysql_binlog_send中的注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /*
    Call fake_rotate_event() in case the previous log (the one which
    we have just finished reading) did not contain a Rotate event.
    There are at least two cases when this can happen:

    - The previous binary log was the last one before the master was
      shutdown and restarted.

    - The previous binary log was GTID-free (did not contain a
      Previous_gtids_log_event) and the slave is connecting using
      the GTID protocol.

    This way we tell the slave about the new log&#39;s name and
    position.  If the binlog is 5.0 or later, the next event we
    are going to read and send is Format_description_log_event.
  */
  if ((file=open_binlog_file(&amp;amp;log, log_file_name, &amp;amp;errmsg)) &amp;lt; 0 ||
      fake_rotate_event(net, packet, log_file_name, BIN_LOG_HEADER_SIZE,
                        &amp;amp;errmsg, current_checksum_alg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是解决之前没有rotate event发送的场景&lt;/p&gt;

&lt;p&gt;虽然非常想吐槽，但是我也想不出更好的办法&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql rpl_slave.cc:handle_slave_io 源码的一些个人分析</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-20-mysql-handle_slave_io-src</link>
      <pubDate>Sun, 20 Oct 2013 20:17:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-20-mysql-handle_slave_io-src</guid>
      <description>

&lt;p&gt;读了rpl_slave.cc:handle_slave_io的源码（Mysql 5.6.11），总结一下&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;函数概述&lt;/h2&gt;

&lt;p&gt;handle_slave_io是slave io_thread的主函数，函数逻辑入口为rpl_slave.cc:start_slave_threads&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;主体结构&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;handle_slave_io(master_info) {
     3955 bla bla…
     4016 fire HOOK binlog_relay_io.thread_start
     4032 与master建立连接
    (4047 设置max_packet_size)
     4073 get_master_version_and_clock,
          在master上：
          通过SELECT UNIX_TIMESTAMP()获取server timestamp
          通过SHOW VARIABLES LIKE &#39;SERVER_ID&#39;获取server id
          SET @master_heartbeat_period= ?
          SET @master_binlog_checksum= @@global.binlog_checksum
          SELECT @master_binlog_checksum获取master binlog checksum
          SELECT @@GLOBAL.GTID_MODE
     4075 get_master_uuid
          在master上“SHOW VARIABLES LIKE &#39;SERVER_UUID&#39;”
     4077 io_thread_init_commands
          在master上“SET @slave_uuid= &#39;%s&#39;”
     4106 register_slave_on_master
          向master发送COM_REGISTER_SLAVE
     4133 while (!io_slave_killed(thd,mi))
     4134 {
     4136      request_dump
               向master发送COM_BINLOG_DUMP_GTID/COM_BINLOG_DUMP
     4159      while (!io_slave_killed(thd,mi))
     4160      {
     4169           read_event，此为阻塞方法，会阻塞等待有新数据包传入
     4184          {
                         一些包错误的处理，包括packet too large / out of resource等
     4213          }
     4219          fire HOOK binlog_relay_io.after_read_event
     4232          queue_event，将event放入relay log写buf
     4240          fire HOOK binlog_relay_io.after_queue_event
     4250          flush_master_info，将master_info和relay log刷到disk上
                   此处，先刷relay log，后刷master_info。这样意外的故障可以通过重连恢复机制来恢复。
                   若先刷master_info，后刷relay log，意外故障时master_info已经更新，比如(0-100, 100-200)，而数据丢失，仅有(0-100)，恢复的replication会从200开始。整个relay log会成为(0-100, 200-)，中间数据会丢失。

     4286          若relay log达到容量限制，则wait_for_relay_log_space
     4292      }
     4293 }
     4296 之后都是收尾操作        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;一些重点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;此处不分析锁什么的，因为看不懂&lt;/li&gt;
&lt;li&gt;4047 设置max_packet_size的目的不明&lt;/li&gt;
&lt;li&gt;4073 开始slave会向master直接发送一些sql，然后解析返回。而不是包装在某个包的某个字段里，用一些预定义的变量来传递结果。&lt;br/&gt;这种设计一下就觉得山寨起来。&lt;br/&gt;后经同事 @神仙 指点，mysql这样做貌似是为了兼容性，免得数据包格式被改来改去。&lt;br/&gt;（看到mysql里大量的兼容代码都拿来处理包结构的问题，最极品的可能是莫过于LOG_EVENT_MINIMAL_HEADER_LEN了）&lt;br/&gt;在对流量影响不大的情况下，直接用sql反复查询的确是个好的解决手法&lt;/li&gt;
&lt;li&gt;4250 将master_info和relay log刷到disk上。&lt;br/&gt;先刷relay log，后刷master_info。这样意外的故障可以通过relay log恢复机制来恢复。&lt;br/&gt;若先刷master_info，后刷relay log，意外故障时master_info已经更新，比如(0-100, 100-200)，而数据(100-200)丢失，仅有(0-100)，恢复的replication会从200开始。整个relay log会成为(0-100, 200-)，中间数据会丢失。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;start slave时slave向master发送的事件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
SELECT UNIX_TIMESTAMP() (rpl_slave.cc:get_master_version_and_clock)&lt;/li&gt;
&lt;li&gt;SHOW VARIABLES LIKE &amp;lsquo;SERVER_ID&amp;rsquo; (rpl_slave.cc:get_master_version_and_clock)&lt;/li&gt;
&lt;li&gt;SET @master_heartbeat_period=? (rpl_slave.cc:get_master_version_and_clock)&lt;/li&gt;
&lt;li&gt;SET @master_binlog_checksum= @@global.binlog_checksum (rpl_slave.cc:get_master_version_and_clock)&lt;/li&gt;
&lt;li&gt;SELECT @master_binlog_checksum (rpl_slave.cc:get_master_version_and_clock)&lt;/li&gt;
&lt;li&gt;SELECT @@GLOBAL.GTID_MODE (rpl_slave.cc:get_master_version_and_clock)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SHOW VARIABLES LIKE &amp;lsquo;SERVER_UUID&amp;rsquo; （rpl_slave.cc:get_master_uuid）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SET @slave_uuid= &amp;lsquo;%s&amp;rsquo;（rpl_slave.cc:io_thread_init_commands)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;COM_REGISTER_SLAVE(rpl_slave.cc:register_slave_on_master)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;COM_BINLOG_DUMP(rpl_slave.cc:request_dump)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;master与slave的时间差&lt;/h2&gt;

&lt;p&gt;可以看到slave获得master的时间方法就是直接下sql，完全忽略网络延迟等等等等，属于不精准的时间&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://guduwhuzhe.iteye.com/blog/1901707&#34;&gt;这篇文章&lt;/a&gt;从源码级别分析了Seconds_Behind_Master的来源，也给出了备库延迟跳跃的原因。总的来说就是Seconds_Behind_Master不可信。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql rpl_master.cc:mysql_binlog_send 源码的一些个人分析和吐槽</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-16-mysql-mysql_binlog_send-src</link>
      <pubDate>Wed, 16 Oct 2013 22:50:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-16-mysql-mysql_binlog_send-src</guid>
      <description>

&lt;p&gt;读了两天rpl_master.cc:mysql_binlog_send的源码（Mysql 5.6.11），总结一下&lt;/p&gt;

&lt;p&gt;函数的入口是rpl_master.cc:com_binlog_dump，当slave向master请求数据时，在master上调用&lt;/p&gt;

&lt;p&gt;函数参数说明: &lt;br/&gt;log_ident为slave请求的binlog文件名，如&amp;rdquo;mysql-bin.000001&amp;rdquo;&lt;br/&gt;pos为slave请求的binlog位置&lt;br/&gt;slave_gtid_executed为gtid相关，在此忽略&lt;/p&gt;

&lt;p&gt;在此吐槽：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这个函数将近1k行，且缩进混乱，代码折叠困难。最后附的我的笔记中，有整理好的源码下载&lt;/li&gt;
&lt;li&gt;这个函数有两大段近百行的重复代码（1179 &amp;amp; 1553）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;源码的主体结构&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql_binlog_send(…)
{
     0814 … bla bla
     1011 fake_rotate_event
     1028 max_alloed_packet= MAX_MAX_ALLOWED_PACKET
     1038 if (请求的POS不是从binlog开头开始)
     1039 {
               从binlog开头中找到一个FD event(FORMAT_DESCRIPTION_EVENT), 并发送给slave
     1123 }
     1124 else
     1125 {
               FD event可以从正常的replication中传送给slave，此处不做操作
     1127 }
     1132 while (net和the都在运转)
     1133 {
     1143      while (从binlog中读取一个event)
     1144      {
     1178           switch (event_type)
     1179           {
                         分类型处理event
     1281           }
     1283           若event需跳转到下一个binlog(goto_next_binlog), break
     1291           fire HOOK before_send_event
     1300           记录skip_group
     1306           {
                         send last skip group heartbeat?
     1326           }
     1331           向slave发送event
     1348           {
                         处理LOAD_EVENT
     1356           }
     1358           fire HOOK after_send_event
     1369      }
     1391      if (!goto_next_binlog)
     1392      {
                   发送完所有binlog，未发生binlog切换时
     1437          加锁尝试再读取一个event（此时其他进程不能更新binlog），目的是试探之前处理过程中master上是否有更多的binlog写入，若有，则跳转1553处理read_packet
     1451          若没有更多的binlog 
                   {
                        等待更多的binlog写入，等待时发送心跳
     1545          }
     1553          处理read_packet
                   {                         
                        分类型处理event
     1682          }
     1683      }
     1685      if (goto_next_binlog)
               {
                    切换到下一个binlog
               }
     1733 }
     1735 之后是收尾处理
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;重点步骤&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;补发Format Description event。&lt;br/&gt;如果传送从binlog开头开始，那么FD event会正常随着binlog传送；&lt;br/&gt;若传送不从binlog开头开始，则需要补发一个FD event，才开始传送&lt;/li&gt;
&lt;li&gt;如何判断binlog读取完&lt;br/&gt;函数先不加锁读取binlog中的event，读完后，再加锁尝试读取一个event（加锁过程中，没有其他进程写进binlog），若有数据，则继续处理，若没有数据，则说明binlog读取完了，master会阻塞等待新的binlog写入。&lt;br/&gt;这样做主要为了：&lt;br/&gt;1. 不需要一直加锁读取binlog，保障性能；&lt;br/&gt;2. 无锁读取时会有其他进程写binlog，加锁可以保障这些新加的binlog得到妥善安置&lt;/li&gt;
&lt;li&gt;心跳&lt;br/&gt;仅在不传送binlog时（master穷尽了binlog，开始阻塞等待新的binlog写入时）才进行心跳&lt;/li&gt;
&lt;li&gt;Fake Rotate Event&lt;br/&gt;Fake Rotate Event在开始传送和切换binlog时发送到slave。主要作用是通知slave binlog filename，原因在源码comment里写的很清楚。但是很疑惑的是为什么在FD event里并没有binlog filename，这个问题发到了&lt;a href=&#34;http://stackoverflow.com/questions/19375951/in-mysql-replication-why-format-description-event-doesnt-include-binlogs-name&#34;&gt;StackoverFlow&lt;/a&gt;，未有答案。（诶，看看我的stackoverflow的记录就知道，我的问题都是死题）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;TODO&lt;/h2&gt;

&lt;p&gt;有一些东西还是没弄懂，得慢慢读懂其他机制才可以，比如&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;max_alloed_packet是如何作用的&lt;/li&gt;
&lt;li&gt;send last skip group heartbeat的作用&lt;/li&gt;
&lt;li&gt;不同类型的event的具体处理，需要和slave端结合在一起&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;我的笔记&lt;/h2&gt;

&lt;p&gt;我的笔记&lt;a href=&#34;https://app.yinxiang.com/shard/s11/sh/f23e9619-9c3d-47f5-a911-8945d0ee02a5/f4eb8539fb2f99e1481496c994b2c270&#34;&gt;在此&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>mysql 5.6.15 replication中碰到的死锁</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-11-hole-in-mysql-56-replication-dead-lock</link>
      <pubDate>Fri, 11 Oct 2013 21:21:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-10-11-hole-in-mysql-56-replication-dead-lock</guid>
      <description>

&lt;p&gt;简述下今天在mysql 5.6.15上碰到的土亢&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;mysql开启主从复制时，用meb（MySQL Enterprise Backup）做备份会卡住。同时在slave上show slave status也会卡住。&lt;/p&gt;

&lt;p&gt;查看slave上show processlist，可以看到sql thread的状态为 &amp;ldquo;Waiting for commit lock&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;猜测&lt;/h2&gt;

&lt;p&gt;无论是&amp;rdquo;SHOW ENGINE INNODB STATUS&amp;rdquo;还是&amp;rdquo;SHOW OPEN TABLES&amp;rdquo;都没有提供有用的信息，还是一切靠猜&lt;/p&gt;

&lt;p&gt;夜观天象猜到mysql存在bug &lt;a href=&#34;http://bugs.mysql.com/bug.php?id=70307&#34;&gt;&amp;ldquo;Another deadlock on FLUSH TABLES WITH READ LOCK + SHOW SLAVE STATUS&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中描述了sql thread开始执行了transaction，但是没有commit的间隙，在slave上FLUSH TABLES WITH READ LOCK，会出现死锁&lt;/p&gt;

&lt;p&gt;于是猜测，如果meb恰好在slave上某个transaction commit之前做了FLUSH TABLES WITH READ LOCK，然后调用了与&amp;rdquo;SHOW SLAVE STATUS&amp;rdquo;类似的机制获取slave info，那么就会如bug所述卡住。然后mysql由于TABLE LOCk的存在，sql thread也就会卡住。&lt;/p&gt;

&lt;p&gt;BTW：搜一下mysql bug库，会有一些描述类似的bug，其中70307描述最靠谱，且有详细的&lt;a href=&#34;http://bugs.mysql.com/file.php?id=20542&#34;&gt;重现步骤&lt;/a&gt;，我也成功在mysql 5.6.15上重现了bug。&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;结果&lt;/h2&gt;

&lt;p&gt;实验后证明猜对了&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>实验：Mysql master-slave-standby将source从master切换到standby</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-05-13-mysql-master-slave-standby-failover</link>
      <pubDate>Wed, 15 May 2013 22:40:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-05-13-mysql-master-slave-standby-failover</guid>
      <description>&lt;p&gt;尝试了&amp;lt;Mysql High Availability&amp;gt;第四章热备份一节的实验,记录步骤.&lt;/p&gt;

&lt;p&gt;先统一原语,master/slave/standby表示三台机器名,source/target代表replication关系的两端（不适用master/slave用以和机器名区分）.&amp;ldquo;master(3)&amp;ldquo;表示master机器的db里有三条数据1,2,3.&lt;/p&gt;

&lt;p&gt;实验开始.&lt;/p&gt;

&lt;p&gt;.1. 初始状态是存在master-&amp;gt;slave, master-&amp;gt;standby的replication
.2. standby在切换成source时,需要有bin-log和replication user. 在此重新设置master-&amp;gt;standby的replication, 让standby满足要求.&lt;/p&gt;

&lt;p&gt;忽略replication user的部分.&lt;/p&gt;

&lt;p&gt;bin-log的部分在my.cnf里要设置log-bin和log-slave-updates(默认情况下,master-&amp;gt;standby的replication不会写standby的bin-log,需开始standby的log-slave-updates才会写).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server-id               = 3
log_bin                 = /var/log/mysql/mysql-bin.log
...
relay-log-index         = /var/log/mysql/slave-relay-bin.index
relay-log               = /var/log/mysql/slave-relay-bin
log-slave-updates
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.3. 测试一下standby binlog设置成功。可以在master插入一条数据，在standby查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;standby&amp;gt; show binlog events;
+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                   |
+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
| mysql-bin.000001 |    4 | Format_desc |         3 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4                 |
| mysql-bin.000001 |  107 | Query       |         1 |         166 | BEGIN                                                                  |
| mysql-bin.000001 |  166 | Query       |         1 |         257 | use `tac`; insert into test values(8889)                               |
| mysql-bin.000001 |  257 | Xid         |         1 |         284 | COMMIT /* xid=111 */    
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.4. 将replication调整至状态master(3),standby(2),slave(1). 人工造成各db的状态不一致&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master&amp;gt; insert into test values(1);
slave&amp;gt; stop slave;
master&amp;gt; insert into test values(2);
standby&amp;gt; stop slave;
master&amp;gt; insert into test values(3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.5. 想象此时master挂掉,开始将source从master切换成standby&lt;/p&gt;

&lt;p&gt;.6. 在建立standby-&amp;gt;slave的replication之前，需要将standby和slave数据同步(此时slave落后于standby)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 先查看standby从master拿了多少数据
standby&amp;gt; show slave status \G
*************************** 1. row ***************************
...
        Master_Log_File: master-bin.000023
...
        Exec_Master_Log_Pos: 1391
		  
-- 让slave从master上同步到跟standby同样的位置
slave&amp;gt; start slave until master_log_file = &#39;master-bin.000023&#39;, master_log_pos = 1391;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有意思的是此处用了master(其实我们假设master已经坏了&amp;hellip;)。&lt;/p&gt;

&lt;p&gt;.7. 此时可以讲slave的source从master切换到standby. 一个问题就是standby-&amp;gt;slave的开始位置可能是和master-&amp;gt;slave不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- 查看standby binlog的当前位置
mysql&amp;gt; show master status \G
*************************** 1. row ***************************
    File: mysql-bin.000001 
    Position: 796
    Binlog_Do_DB:
	Binlog_Ignore_DB:
-- 注意与master上的文件名和位置都不同

-- 切换slave的source
slave&amp;gt; change master to 
			  master_host = &#39;192.168.50.4&#39;, 
			  master_port = 3306, 
			  master_user = &#39;repl&#39;, 
			  master_password = &#39;repl&#39;, 
			  master_log_file = &#39;mysql-bin.000001&#39;, 
			  master_log_pos = 796;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.8. 测试一下standby-&amp;gt;slave replication.&lt;/p&gt;

&lt;p&gt;总的思路就是讲master(3),standby(2),slave(1)同步成master(3),standby(2),slave(2),然后将master-&amp;gt;slave切换成standby-&amp;gt;slave.&lt;/p&gt;

&lt;p&gt;遗留了两个问题,其一是slave和standby同步时使用了&amp;rdquo;坏掉&amp;rdquo;的master;其二是master超前了standby和slave, 也就是standby-&amp;gt;slave丢失了master的超前数据。留待慢慢学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于Mysql binlog的一点学习</title>
      <link>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-05-12-mysql-binlog-study</link>
      <pubDate>Sun, 12 May 2013 22:59:00 UTC</pubDate>
      
      <guid>http://ikarishinjieva.github.io/tachikoma-blog/post/2013-05-12-mysql-binlog-study</guid>
      <description>

&lt;p&gt;差不多一个月没更新了。除了忙些琐事，就是偷点懒。&lt;/p&gt;

&lt;p&gt;在读&amp;lt;Mysql High Availability&amp;gt;，扫了一遍，读第二遍的时候开始做些实验，所以这之后的blog写的也会没什么章法。&lt;/p&gt;

&lt;p&gt;&amp;lt;Mysql High Availability&amp;gt;第三章介绍binlog时特地提到了Rand()/Now()/User variable/Password()在基于sql复制时的行为，简单做些实验。&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Rand()&lt;/h2&gt;

&lt;p&gt;Rand() 在replication中，值会被正确传递。如下查看binlog，发现pos 209处rand_seed会被传给slave，保证rand生成的值保持一致。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show binlog events in &#39;master-bin.000007&#39;;
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                   |
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
| master-bin.000007 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4 |
| master-bin.000007 | 107 | Query       |         1 |         174 | BEGIN                                                  |
| master-bin.000007 | 174 | RAND        |         1 |         209 | rand_seed1=598597315,rand_seed2=24268577               |
| master-bin.000007 | 209 | Query       |         1 |         302 | use `tac`; insert into test values(rand())             |
| master-bin.000007 | 302 | Xid         |         1 |         329 | COMMIT /* xid=151 */                                   |
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Now()&lt;/h2&gt;

&lt;p&gt;Now() 在replication中，值会被正确传递。如下查看binlog，pos 283处，貌似这个语句传给slave，会由于master和slave的时间不同步，导致问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     master&amp;gt; flush logs;
     master&amp;gt; SET TIMESTAMP=unix_timestamp(&#39;2010-10-01 12:00:00&#39;);
     master&amp;gt; insert into test values(now());
     master&amp;gt; show binlog events in &#39;master-bin.000007&#39;;

+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                   |
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
| master-bin.000012 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4 |
| master-bin.000012 | 107 | Query       |         1 |         182 | BEGIN                                                  |
| master-bin.000012 | 182 | Query       |         1 |         283 | use `tac`; insert into test values (now())             |
| master-bin.000012 | 283 | Xid         |         1 |         310 | COMMIT /* xid=131 */                                   |
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但通过mysqladmin查看binlog，可以看到binlog中会不断插入TIMESTAMP来保证now()函数的执行结果在master和slave是相同的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master&amp;gt; sudo mysqlbinlog --short-form master-bin.000017
... 
DELIMITER /*!*/;
SET TIMESTAMP=1285934400/*!*/;
...
BEGIN
/*!*/;
use `tac`/*!*/;
SET TIMESTAMP=1285934400/*!*/;
insert into test values(now())
/*!*/;
COMMIT/*!*/;
SET TIMESTAMP=1368372377/*!*/;
BEGIN
/*!*/;
SET TIMESTAMP=1368372377/*!*/;
insert into test values(now())
/*!*/;
COMMIT/*!*/;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;User variable&lt;/h2&gt;

&lt;p&gt;User variable会被编码成十六进制串，含义不明，保密性不明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; flush logs;
Query OK, 0 rows affected (0.02 sec)

mysql&amp;gt; set @foo = now();
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; insert into test values (@foo);
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; show binlog events in &#39;master-bin.000014&#39;;
+-------------------+-----+-------------+-----------+-------------+-----------------------------------------------------------------------------------+
| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                                              |
+-------------------+-----+-------------+-----------+-------------+-----------------------------------------------------------------------------------+
| master-bin.000014 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4                            |
| master-bin.000014 | 107 | Query       |         1 |         174 | BEGIN                                                                             |
| master-bin.000014 | 174 | User var    |         1 |         229 | @`foo`=_latin1 0x323031302D31302D30312031323A30303A3030 COLLATE latin1_swedish_ci |
| master-bin.000014 | 229 | Query       |         1 |         321 | use `tac`; insert into test values (@foo)                                         |
| master-bin.000014 | 321 | Xid         |         1 |         348 | COMMIT /* xid=148 */                                                              |
+-------------------+-----+-------------+-----------+-------------+-----------------------------------------------------------------------------------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Password()&lt;/h2&gt;

&lt;p&gt;直接内嵌使用password，会在binlog里暴露密码，就像下面的测试。可以使用user variable,但是不知道user variable的编码保密性如何。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; insert into test values(password(&#39;tac&#39;));
mysql&amp;gt; show binlog events in &#39;master-bin.000015&#39;;
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
| Log_name          | Pos | Event_type  | Server_id | End_log_pos | Info                                                   |
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
| master-bin.000015 |   4 | Format_desc |         1 |         107 | Server ver: 5.5.31-0ubuntu0.12.04.1-log, Binlog ver: 4 |
| master-bin.000015 | 107 | Query       |         1 |         174 | BEGIN                                                  |
| master-bin.000015 | 174 | Query       |         1 |         276 | use `tac`; insert into test values(password(&#39;tac&#39;))    |
| master-bin.000015 | 276 | Xid         |         1 |         303 | COMMIT /* xid=158 */                                   |
+-------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+
4 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单一点学习如上。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>